---
categories: hexo
title: 配置一个很舒服的终端
tags:
  - Iterm
  - zsh
  - 主题
date: 2018-01-19 13:35:43
---
好吧，程序员学习真的是没有尽头的，，这段时间都是在调整我的博客，在调整博客的过程中其中的一件事儿，我觉的引发了好多事儿，特此记录一下的。     
写完了博客之后，发觉自己的博客没有绿色的小锁，所以想搞https 证书认证，可以查看我的另一篇博客 Hexo本地搜索，在搜索栏直接查看就好了的（搜索 “HEXO 本地搜索 或者本地搜索”）。          
使用了Https之后导致，我的七牛云的资源，引入的时候因为七牛的图片都是`http`的，全部都加载失败了。我自然而然的觉的开启了七牛云的https就好了的，我就开始尝试去开启七牛云的`https`。         
两种方式，一种是在他们上面申请一个SSL证书，要不然就是上传自己的证书。（唉，知识真的非常浅薄，只知道https，但是不知道到底是怎么回事儿。
这个问题会专门写一篇文章去记录我学习https的过程。），虽然现在市面上的https证书都是需要收费的并且价格不菲，但是我还是找到了免费的证书。接下来就是上传了，，，，日！  我TM甚至不知道怎么上传。。。。

<!--more-->

好吧，我放弃了，但是我真的想看看我的小锁，会不会出现我的名字，所以我就开始搞以前一直想做但是一直没有做的东西，`nginx` ，好吧，我甚至不了解这个服务器，真是难过，什么都不会，以前就会一个 Tomcat ，还是就会一些最基本的操作。 没办法学习吧。另外讲（搜索 nginx 查看文章）

在我学习 nginx之后，发现了一个问题，我Iterm2 代码没有高亮！！！！

真的，讲了这么多才讲到这里。。。。我真的也是醉了，，，好吧我们言归正传！

### 什么是 ZSH
zsh是什么东西，其实他是一个 shell解释器。
> Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。

这个问题有些大，总的来说，你写了一个脚本，比如，`js`,`Perl`,`Ruby`,`Python`,`sh`,`csh`等等，这些东西都是脚本。脚本语言是为了解决以前的【编写->编译->链接->运行】这些过程才能运行的语言而出现的。脚本通常需要的是 解释执行，脚本语言不会像`c\c++\java`等可以编译成二进制代码，以可执行的文件形式存在，脚本语言是不需要编译的，可以直接有解释器解释运行。      
而zsh就是其中一种，他有什么特点呢？
> Zsh是一个Linux用户很少使用的shell，这是由于大多数Linux产品安装，以及默认使用bash shell。几乎每一款Linux产品都包含有zsh，通常可以用apt-get、urpmi或yum等包管理器进行安装。

额，，，我们的百度狠狠的diss了一下ZSH，以下是这个解释器的特点。
* Zsh具有以下主要功能：
* 开箱即用、可编程的命令行补全功能可以帮助用户输入各种参数以及选项。
* 在用户启动的所有shell中共享命令历史。
* 通过扩展的文件通配符，可以不利用外部命令达到find命令一般展开文件名。
* 改进的变量与数组处理。
* 在缓冲区中编辑多行命令。
* 多种兼容模式，例如使用/bin/sh运行时可以伪装成Bourne shell。
* 可以定制呈现形式的提示符；包括在屏幕右端显示信息，并在键入长命令时自动隐藏。
* 可加载的模块，提供其他各种支持：完整的TCP与Unix域套接字控制，FTP客户端与扩充过的数学函数。
* 完全可定制化。
好吧，我觉得他的好处也很简而易见
1. 兼容
2. 可加载模块
3. 完全可定制化！！！！

### 什么是 oh-my-zsh

好吧，因为这些特点，我们的现在就需要的就是 `oh-my-zsh`这个 ZSH的框架了。omz这个框架可以说，他整理很多的 组建以及定义了非常多的好看的样式。那么我们来安装他们吧。。。。      
好吧，我们来检查以下 zsh的版本，以及我们需要设置默认的shell解释器。 另外我们的 ohmyzsh 需要版本至少 4.3.9 或者更高的。
查看自己的shell 解释器都有哪些,如果没有 zsh 需要[安装](https://github.com/robbyrussell/oh-my-zsh)。
````shell
cat /etc/shells

### ---> 结果
# List of acceptable shells for chpass(1).
# Ftpd will not allow users to connect who are not using
# one of these shells.

/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh

### ---> 如果没有安装

### ---> 默认来使用 zsh
chsh -s `which zsh`

### ---->  查看是否设置成功
echo $SHELL
````
确认自己有了之后，就可以安装 oh-my-zsh le .
via curl
````
sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
````
via wget
````
sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"
````

#### oh-my-zsh 主题
其实这个时候我们发现已经可以变化了。打开终端之后，发现已经是变了个样子了

打开终端之后，已经好了，发现已经是变了个样子了，但是如何美化呢。那么我们就需要配置 Theme了，你可以在[主题列表](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)预览和选择自己喜欢的主题了。修改地址的话是在 `~/.zshrc`文件中。配置
````sehll
ZSH_THEME="robbyrussell"
````
当然你要是觉的一种配色太单调。。。你可以随机
````sehll
ZSH_THEME="agnoster" # (this is one of the fancy ones)
````
这个时候重启之后就可以看到好看的样式了～选择一个自己喜欢的吧～
#### oh-my-zsh 组件
oh-my-zsh提供了一些非常方便的组件植入方式。
以 powerline-shell 为例子
````
# 首先下载 组件
git clone https://github.com/b-ryan/powerline-shell ~/.oh-my-zsh/custom/plugins
````
设置 组件的启用 在 ~/.zshrc 中
````
function powerline_precmd() {
    PS1="$(powerline-shell --shell zsh $?)"
}

function install_powerline_precmd() {
  for s in "${precmd_functions[@]}"; do
    if [ "$s" = "powerline_precmd" ]; then
      return
    fi
  done
  precmd_functions+=(powerline_precmd)
}

if [ "$TERM" != "linux" ]; then
    install_powerline_precmd
fi
````
这样我们就成功的完成了 Powerline 的安装了。

### powerline 字体
这个东西就是设置一个更好看，更易用的 Sehll prompt（终端提示符）的东西。     
按照上面的例子我们已经安装完成了，但是这个时候我们还可以发现。乱码了,,,日，好吧。这个时候，我们需要设置一些字体了。首先我们要将这些字体安装到我们的机器上。
````sehll
# 将字体现在下来
git clone https://github.com/powerline/fonts.git --depth=1
# 进入文件夹中之后 安装文件
cd fonts
./install.sh
# 之后咋们就可以删除咱们下载的文件了
cd ..
rm -rf fonts
````
在这个时候我们打开我们的终端客户端，比如 Iterm2 或者 自带的客户端，设置他的字体。为带有 `powerline`结尾的字体就好了。

PS： 在设置 Iterm2 的时候，我设置了字体还是出现乱码，但是当我关闭了 `Use a different font for non-ASCLL txt`选项之后就好了。

### powerline 的主题
好吧，，，都是主题！  都是主题！！！

默认的话 powerline 是没有配置主题的，我们需要在sehll 运行
````shell
powerline-shell --generate-config > ~/.powerline-shell.json
````
生成了之后，我们就可以配置主题等文件了[更多查看](https://github.com/b-ryan/powerline-shell#customization)。

这个时候，我们就已经可以看到我们的成果了。
