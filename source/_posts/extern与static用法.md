---
categories: 学习资料
title: extern与static用法
tags:
  - c
  - c++
permalink: externystaticyf
date: 2018-01-22 19:32:00
---

### c/c++ 中的 Static
在C语言中，static可以用来修饰局部变量，全局变量以及函数。在不同的情况下static的作用不尽相同。

在C++中static还具有其它功能，如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。对于静态成员函数，只能访问静态成员函数和静态成员变量，不能访问非静态成员函数或者变量。

### c/c++ 中的 extern

在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

在上面的例子中可以看出，在file2中如果想调用file1中的变量a，只须用extern进行声明即可调用a，这就是extern的作用。在这里要注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。

<!--more-->


### 展开说明

在讨论全局变量之前我们先要明白几个基本的概念：

1. 编译单元(模块)：       
    在IDE开发工具大行其道的今天，对于编译的一些概念很多人已经不再清楚了，很多程序员最怕的就是处理连接错误(LINK ERROR), 因为它不像编译错误那样可以给出你程序错误的具体位置，你常常对这种错误感到懊恼，但是如果你经常使用gcc，makefile等工具在linux或者嵌 入式下做开发工作的话，那么你可能非常的理解编译与连接的区别！当在VC这样的开发工具上编写完代码，点击编译按钮准备生成exe文件时，VC其实做了两 步工作，第一步，将每个.cpp(.c)和相应.h文件编译成obj文件；第二步，将工程中所有的obj文件进行LINK生成最终的.exe文件，那么错 误就有可能在两个地方产生，一个是编译时的错误，这个主要是语法错误，另一个是连接错误，主要是重复定义变量等。我们所说的编译单元就是指在编译阶段生成 的每个obj文件，一个obj文件就是一个编译单元，也就是说 **一个cpp(.c)和它相应的.h文件共同组成了一个编译单元，一个工程由很多个编译单元组 成，每个obj文件里包含了变量存储的相对地址等** 。
2. 声明与定义的区别      
    **函数或变量在声明时，并没有给它实际的物理内存空间**，它有时候可以保证你的程序编译通过， **但是当函数或变量定义的时候，它就在内存中有了实际的物理空间**，如果你在编译模块中引用的外部变量没有在整个工程中任何一个地方定义的话， 那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量！你也可以这样理解， 对同一个变量或函数的声明可以有多次，而定义只能有一次!
3. extern的作用
    extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b); 则告诉编译器在编译fun这个函数名时 **按着C的规则去翻译相应的函数名而不是C++的**， C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了 (不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可 以得到满意的解释!         
    **当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或者其他模块中使用，记住它是一个声明不是定义!** 也就是说B模块(编译 单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可, 在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

如果你对以上几个概念已经非常明白的话，那么让我们一起来看以下几种全局变量/常量的使用区别:

### 用extern修饰的全局变量
以上已经说了extern的作用，下面我们来举个例子,如:
在test1.h中有下列声明:
````cpp
#ifndef TEST1H
#define TEST1H
extern char g_str[]; // 声明全局变量g_str
void fun1();
#endif
````
在test1.cpp中
````cpp
#include "test1.h"

char g_str[] = "123456"; // 定义全局变量g_str

void fun1()
{
  cout << g_str << endl;
}
````
以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了

````cpp
#include "test1.h"

void fun2(){

  cout << g_str << endl;
}
````
以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面着"123456"这 个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份, test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!
有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为

````cpp
extern char g_str[] = "123456"; // 这个时候相当于没有extern
````
然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，**会报连接错误**，这是因为你把全局变量 g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而 test2.cpp也包含了test1.h所以再一次定义了g_str, **这个时候连接器在连接test1和test2时发现两个g_str**。如果你非要把g_str的定义放在test1.h中的话，那么就把test2的代码 中#include "test1.h"去掉 换成:
````cpp
extern char g_str[];
void fun2()
{
  cout << g_str << endl;
}
````
这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是我想说这样做非常糟糕，因为你由于无法在 test2.cpp中使用#include "test1.h", 那么test1.h中声明的其他函数你也无法使用了，除非也用都用extern修饰，这样的话你光声明的函数就要一大串，而且头文件的作用就是要给外部提 供接口使用的，所以 请记住， **只在头文件中做声明，真理总是这么简单**。

### 用static修饰的全局变量
首先，**我要告诉你static与extern是一对“水火不容”的家伙**，也就是说extern和static不能同时修饰一个变量；其次，**static修 饰的全局变量声明与定义同时进行**，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，**static修饰全局变量的作用域 只能是本身的编译单元**，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:

test1.h:
````cpp
#ifndef TEST1H
#define TEST1H
static char g_str[] = "123456";
void fun1();
#endif
````
test1.cpp:
````cpp
#include "test1.h"

void fun1()
{
    cout << g_str << endl;
}

````
test2.cpp
````cpp
#include "test1.h"

void fun2()
{
    cout << g_str << endl;
}
````
以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456", 同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样， 就像是两个不同变量赋了相同的值一样，**而这两个变量分别作用于它们各自的编译单元**。      
也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1, test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编 译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上 面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了， 如果你把上面的代码改成下面的样子，你马上就可以 **拆穿编译器的谎言**:

test1.cpp:
````cpp
#include "test1.h"

void fun1()
{
    g_str[0] = 'a';
    cout << g_str << endl;
}
````
test2.cpp
````cpp
#include "test1.h"

void fun2()
{
    cout << g_str << endl;
}

void main()
{
    fun1(); // a23456
    fun2(); // 123456
}
````
这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以 **编译器被强行的恢复内存的原貌**，在内存中存在了两份拷贝给两个模块中的变量使用。

**正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染，同样记住这个原则吧！**

### 转载

* [浅谈C/C++中的static和extern关键字](https://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022701.html)
* [【转】extern与static用法](https://www.cnblogs.com/M-book/archive/2011/10/12/2208734.html)
