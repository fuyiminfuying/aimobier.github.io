---
title: Pthreads 学习4 - 锁
tags:
  - IOS
  - POSIX
  - Pthreads
  - 线程
categories: 线程
date: 2018-01-10 23:22:00
---
我也已经学习了挺久了，那么接下来我会进行一些总结性的记录。

线程，就是进程中的一个动作，比如者活着是进程，那么吃饭就算是线程，当然跑步也算线程。
线程有几个属性，             
CancelState 规定了，这个线程是否可以取消，比如跳楼，这个进程就不能返回。再比如说，坐公交车是可以随时不做的。但是这就牵涉到了怎么取消了       
CancelType，一种是 deffered延期的，啥意思呢？ 前面不是说了 坐公交车可以取消。那么这个 type的意思就是，你会在下一站下车，而不是想反回就返回的。另一种是 async 这种就比较暴躁了... 说要取消，立马取消！“老子才不管到没到站！给老子停车！！！！  行！  不听是吧！我跳！车！”       
specific，线程中的私有公共变量，在同一个线程中可以获取到的值，需要使用 pthread_key_t 来存储。大概的意思就是，比如跑步的时候 终点在哪儿，无论在跑步这个线程任何时间都是知道的，但是做饭这个线程就不需要知道这个 终点。     
schedparam，

<!-- more -->

## concurrency
并发级别，查找到的资料说的，用户级线程可以映射的内核线程或进程的数目。

## schedparam

设置线程的调度策略和优先级。

### 调度策略

线程的调度有三种策略：SCHED_OTHER、SCHED_RR和SCHED_FIFO。Policy用于指明使用哪种策略。下面我们简单的说明一下这三种调度策略。
SCHED_OTHER           
它是默认的线程分时调度策略，所有的线程的优先级别都是0，线程的调度是通过分时来完成的。简单地说，如果系统使用这种调度策略，程序将无法设置线程的优先级。请注意，这种调度策略也是抢占式的，当高优先级的线程准备运行的时候，当前线程将被抢占并进入等待队列。这种调度策略仅仅决定线程在可运行线程队列中的具有相同优先级的线程的运行次序。

SCHED_FIFO         
它是一种实时的先进先出调用策略，且只能在超级用户下运行。这种调用策略仅仅被使用于优先级大于0的线程。它意味着，使用SCHED_FIFO的可运行线程将一直抢占使用SCHED_OTHER的运行线程J。此外SCHED_FIFO是一个非分时的简单调度策略，当一个线程变成可运行状态，它将被追加到对应优先级队列的尾部((POSIX 1003.1)。当所有高优先级的线程终止或者阻塞时，它将被运行。对于相同优先级别的线程，按照简单的先进先运行的规则运行。我们考虑一种很坏的情况，如果有若干相同优先级的线程等待执行，然而最早执行的线程无终止或者阻塞动作，那么其他线程是无法执行的，除非当前线程调用如pthread_yield之类的函数，所以在使用SCHED_FIFO的时候要小心处理相同级别线程的动作。

SCHED_RR         
鉴于SCHED_FIFO调度策略的一些缺点，SCHED_RR对SCHED_FIFO做出了一些增强功能。从实质上看，它还是SCHED_FIFO调用策略。它使用最大运行时间来限制当前进程的运行，当运行时间大于等于最大运行时间的时候，当前线程将被切换并放置于相同优先级队列的最后。这样做的好处是其他具有相同级别的线程能在“自私“线程下执行。

### 优先级

sched_priority
当你得到调度参数时，这个成员反映了分配给线程或进程的优先级。它并不反映由于继承优先权而进行的任何临时调整。
设置计划参数时，请将此成员设置为您要使用的优先级。调度策略的优先级必须在sched_get_priority_min（）和sched_get_priority_max（）返回的最小值和最大值之间。

sched_curpriority
当你得到调度参数时，这个成员被设置为线程或进程当前正在运行的优先级。这是内核在进行调度决策时使用的值。
当您设置计划参数时，该成员将被忽略。

其他成员用于零星调度。以下#define指令创建与这些成员相对应的POSIX名称，而不是直接访问成员。

sched_ss_low_priority
正在执行的线程的后台或低优先级。
sched_ss_max_repl
补货计划的最大次数，通常是因为阻塞操作。在一个线程多次被阻塞之后，它会自动下降到低优先级，直到其执行预算被补充。
sched_ss_repl_period
在被阻止或超出最大补货数量后，应该用于计划补货执行预算的时间。这个时间被用作一个线程被准备就绪的时间的偏移量。
sched_ss_init_budget
应该用于线程执行预算的时间。由于线程以高优先级运行，其执行时间被划分为这个预算。一旦预算完全耗尽，线程将下降到低优先级，在可能的情况下，由于优先级安排，线程可以继续运行，直到执行预算得到补充。

## specific
局部存储变量          

## 互斥锁

### type

如果互斥量类型为`PTHREAD_MUTEX_NORMAL`，则不提供死锁检测。 试图重新锁定互斥锁会导致死锁。 如果线程试图解锁未锁定的互斥锁或未锁定的互斥锁，则会导致未定义的行为。

如果互斥类型为`PTHREAD_MUTEX_ERRORCHECK`，则应提供错误检查。 如果线程试图重新锁定已锁定的互斥锁，则应返回错误。 如果线程试图解锁未锁定的互斥锁或解锁的互斥锁，则应返回错误。

如果互斥体类型是`PTHREAD_MUTEX_RECURSIVE`，那么互斥体应该保持锁计数的概念。 当线程第一次成功获取互斥锁时，锁定计数应设置为1。 每当一个线程重新锁定这个互斥锁，锁定计数应该加1。 每次线程解锁互斥锁时，锁定计数应减1。 当锁计数达到零时，互斥锁将变为可用于其他线程获取。 如果线程试图解锁未锁定的互斥锁或解锁的互斥锁，则应返回错误。

如果互斥体类型是`PTHREAD_MUTEX_DEFAULT`，则试图递归锁定互斥体将导致未定义的行为。 试图解锁互斥锁，如果它没有被调用线程锁定导致未定义的行为。 试图解锁互斥锁，如果它没有被锁定导致未定义的行为。

### pshared
设置是否分享该互斥变量锁住的值。

进程共享属性被设置为PTHREAD_PROCESS_SHARED，以允许任何有权访问互斥量被分配的内存的线程操作互斥量，即使互斥量被分配到多进程共享的内存中。 如果进程共享属性是PTHREAD_PROCESS_PRIVATE，互斥量只能由与初始化互斥量的线程在同一进程内创建的线程操作; 如果不同进程的线程试图在这样的互斥体上进行操作，则行为是不确定的。 属性的默认值应该是PTHREAD_PROCESS_PRIVATE
