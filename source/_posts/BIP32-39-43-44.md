---
categories: 区块链
title: BIP32 39 43 44
tags:
  - HD Wallet
  - BIP32-44
date: 2018-3-23 17:25:00
---
## 什么是BIP

[bips](https://github.com/bitcoin/bips) 是存在 bitcoin 组织的一个项目，他的作用是改进 bitcoin。

在他的内容下面，我们可以看到这些组织的宣言,简单的翻一下，大致如下：

> People wishing to submit BIPs, first should propose their idea or document to the (bitcoin-dev@lists.linuxfoundation.org)[bitcoin-dev@lists.linuxfoundation.org] mailing list. After discussion, please open a PR. After copy-editing and acceptance, it will be published here.
>
> We are fairly liberal with approving BIPs, and try not to be too involved in decision making on behalf of the community. The exception is in very rare cases of dispute resolution when a decision is contentious and cannot be agreed upon. In those cases, the conservative option will always be preferred.
>
> Having a BIP here does not make it a formally accepted standard until its status becomes Final or Active.
>
> Those proposing changes should consider that ultimately consent may rest with the consensus of the Bitcoin users (see also: [economic majority](https://en.bitcoin.it/wiki/Economic_majority)).

其实意思就是说，我们这里呢，是放如何让我们的bitcoin改进建议的！在这里，我们这个社区不会独裁专制，我们不会独行的决定某一个建议是否可行。这需要大多数的人的共识。

当然，如果真的发生了争执，我们会选择保守的方式。猥琐发育！

<!-- more -->

## BIP 规则

在 [BIP-001](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki),规定了一些BIP的规则。

在这里发言也是有很多限制的，比如发言的方式。他的规则使用的是邮件的样式 RFC 822。另外处理这些东西是一个人，你需要发送邮件给他，来获取你的BIPID 也就是咱们说的 BIP34中的34这个ID，这不是随便使用的。

总之非常多的规矩，其中 [BIP-0001](https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki)和[BIP-0002](https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki) 介绍了规则。但是和我们没有任何关系，我们只需要这里面的东西，有用的东西绝对有！但是没用的东西也是存在的～

### BIP的类型

一共有三种BIP类型。
* Standards: 这类型的建议都是影响了大多数或者比特币实现的。比如忽然我们觉的不实用我们现在的POW共识了，我们不使用我们现在的网络协议了。或者小一点的影响到了应用层
* Informational: 这类型的建议就真的是建议了。他是说出一些比特币的设计问题，或者提出一些指导，意见，信息，但不包括新功能！这一类的BIP不一定代表共识，所以用户和实施者，可以自己觉的是忽视这个bip还是遵循他的建议
* Process: 这类讲的是，围绕着比特币的流程，或者提出对流程或者流程中的事件改变。Process 和 Standards类似，但是它适用于任何比特币协议本身和意外的领域。可能会提出一个实施方案，而不是比特币的代码。他们通常需要社区共识; 与信息型BIP不同，它们不仅仅是建议，而且用户通常不会无视它们。例子包括程序，指导方针，决策过程的变化以及比特币开发中使用的工具或环境的变化。 任何meta-BIP也被认为是一个Process BIP。

## BIP 32 39 43 44 关系

* 32 提出了HD钱包，完成多币种多账户管理。分层为 `m/0'/*`
* 39 提出了使用12个助记词来 替换 这个随机数字... 我觉的还是难记的... 毕竟这些词是也随机的...
* 43 提出了 32 提出的多用途很好！但是没有给出一个规范，很多软件没办法统一 分层为 `m/purpose'/*`
* 44 基于43的建议完成了 多层的分层 `m / purpose' / coin_type' / account' / change / address_index`

我们会在最后说明到32

### BIP 0039

就是建议使用若干个助记词来产生，随机种子。

#### 助记词列表

其中WordList，是存在[这里](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md)的。
包含以下语言,每种语言都存在2048个单词，来成为助记词备选者。每一种语言都提供对了对应的2048个词。其中都包含了，英文，日文，汉语，西班牙语，简体中文，繁体中文，法语，意大利。
````ruby
English
Japanese
Korean
Spanish
Chinese (Simplified)
Chinese (Traditional)
French
Italian
````
这些词也是有考究的，因为他需要保证，这些词全部都可以在11 bits中表示，否则在下面的推导公式就会出现问题。因为这些词语是通过随机的 128-256bits随机种子产生的助记词。所以，这些词是随机的。

##### 这些词是不是安全的？
好吧，我觉得 随机的东西... 主要有足够的时间，**无限猴子理论**。我觉的绝对会有重复的一天，到时候，我会和另一个人拥有同样的Master Seed！！！

当然....几率有多小呢。。。我们来说 你如果使用的是 128为的随机种子。你会产生12个助记词。他的出现的组合个数是
$$A^{m}_{n}=n\left( n-1\right) \ldots \left( n-m+1\right) =\dfrac {n!}{\left( n-m\right) !}$$
上方为m中抽取n个的排列总和计算总数。
$$\dfrac {2048!}{\left( 2048-12\right) !}$$
这个还只是，没有排列顺序的方式，他抽取的助记词，顺序也是一种随机因素。所以只会比这个还大。
我们知道的双色球的红色球组合总数是
$$\dfrac {33!}{\left( 33-6\right) !}$$
这个几率就已经很少有人中奖了... 何况这么大...
emmmmm... 至少，我算不出来他的几率是多少。。。因为光是2048 的阶乘,,,就写满了一页纸。。。。

#### 生成的方式

接下来会说明下，生成助记词和通过助记词生成Master种子的原理

#### 生成助记词的过程

1. 规定熵的位数必须是 32 的整数倍，所以熵的长度取值位 128 到 256 之间取 32 的整数倍的值，分别为 128, 160, 192, 224, 256；
2. 校验和的长度为熵的长度/32 位, 所以校验和长度可为 4，5，6，7，8 位
3. 助记词库有 2048 个词，用 11 位可全部定位词库中所有的词，作为词的索引，故一个词用 11 位表示，助记词的个数可为 (熵+校验和)/11，值为 12，15，18，21，24

| 熵(bits) | 校验和(bits) | 熵+校验和(bits) |助记词 |
| - | :-: | -: | -:|
| 128 | 4 | 132 | (132/32) -> 12|
| 160 | 4 | 165 | (132/32) -> 15|
| 192 | 4 | 198 | (132/32) -> 18|
| 224 | 4 | 231 | (132/32) -> 21|
| 256 | 4 | 264 | (132/32) -> 24|

````ruby
## CS 为 校验和的长度
CS = ENT / 32
## MS 为 助记词的个数
MS = (ENT + CS) / 11

|  ENT  | CS | ENT+CS |  MS  |
+-------+----+--------+------+
|  128  |  4 |   132  |  12  |
|  160  |  5 |   165  |  15  |
|  192  |  6 |   198  |  18  |
|  224  |  7 |   231  |  21  |
|  256  |  8 |   264  |  24  |
````

步骤如下：
1. 生成一个长度为 128~256 位 (bits) 的随机序列(熵)
2. 取熵哈希后的前 n 位作为校验和 (n= 熵长度/32)
3. 随机序列 + 校验和
4. 把步骤三得到的结果每 11 位切割
5. 步骤四得到的每 11 位字节匹配词库的一个词
6. 步骤五得到的结果就是助记词串

![](/publicFiles/images/BIP32-39-43-44/18473-2b7a5a54bfb9b0e7.png "生成助记词过程")

#### 助记词生成Seed的过程

为了从助记词中生成二进制种子，BIP39 采用 [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) 函数推算种子，其参数如下：

* 助记词句子作为密码
* "mnemonic" + passphrase 作为盐
* 2048 作为重复计算的次数
* HMAC-SHA512 作为随机算法
* 512 位(64 字节)是期望得到的密钥长度

![](/publicFiles/images/BIP32-39-43-44/18473-1ca2010125693f37.png "助记词推出随机种子")

### BIP 0032

在这里的时候，无论是我们直接生成`Master Seed`还是通过`BIP39` 来生成 `Master Seed`我们都已经有随机种子了。
记下来让我们来看看下面的过程吧。

#### 主私钥和主链码
有了根种子之后，我们需要从根种子生成主密钥 (master key) 和主链码 (master chain code)
![](/publicFiles/images/BIP32-39-43-44/18473-087acc13fddce758.png "推导出主密钥主链码")
上图中根种子通过不可逆 HMAC-SHA512 算法推算出 512 位的哈希串，左 256 位是 Master Private key(m), 右 256 位是 master chain code, 通过 m 结合推导公钥的椭圆曲线算法能推导出与之对应的 264 位 master public Key (M)。chain code 作为推导下级密钥的熵。

#### 子私钥推导
HD 钱包使用 CKD(child key derivation) 函数从父密钥(parent keys)推导子密钥(child keys)，CKD 由下列三个要素做单向散列哈希(one way hash function) 。

* 父密钥 (没有压缩过的椭圆曲线推导的私钥或公钥 ECDSA uncompressed key)
* 链码作为熵 (chain code 256 bits)
* 子代索引序号 (index 32 bits)

![](/publicFiles/images/BIP32-39-43-44/18473-42795e6c1c38e801.png "子私钥推导")

索引号个数为 2 的 32 次方，每个父级密钥能推导出该数目一半的子密钥 (
索引号从 0x00 到 0x7fffffff (0 to 2 的 21 次方减 1) 会生成正常的密钥；索引号从 0x80000000 到 0xffffffff 会生成增强密钥）。CKD 采用不可逆的 HMAC-SHA512 不可逆加密算法，子密钥不能向上推导出父密钥、同时也不能水平推导出同一级的密钥。

#### 扩展密钥
CKD 推导子密钥的三个元素中，其中父密钥和链码结合统称为扩展密钥 (Extended keys)。256 位的密钥和 256 位的链码串联起来的 512 位就是扩展密钥。

1. 包含私钥的扩展密钥用以推导子私钥，从子私钥又可推导对应的公钥和比特币地址
2. 包含公钥的扩展密钥用以推导子公钥
扩展密钥使用 Base58Check 算法加上特定的前缀编码，编码得到的包含私钥的前缀为 xprv, 包含公钥的扩展密钥前缀为 xpub，相比比特币的公私钥，扩展密钥编码之后得到的长度为 512 或 513 位。

#### 子公钥推导
上述方法中通过推导出的私钥可推导出对应公钥，但 HD 钱包非常好用的特征之一就是在隐藏私钥的前提下通过公钥推导出子公钥，极大加强安全性。在只需要生成地址接受比特币而无权消费的场景下非常有用，通过公钥扩展密钥能生成无穷尽的公钥和比特币地址。

HD 钱包通过公钥推导子公钥的使用场景：在接受数字货币支付的电商系统中，Web 服务中集成了比特币扩展公钥服务，系统为客户的每笔订单生成一个接受比特币支付的地址，不涉及到私钥的 web 服务极大地减低了被盗币的可能性。如果不采用 HD 钱包，通常都是在物理隔绝的服务器中批量生成比特币地址，然后再导入到电商系统，这种方式需要定时生成并导入地址维护防止 web 服务系统把预先导入的地址用完。

子私钥推导流程和子公钥流程基本一样，差异之处有两点：

1. 把子私钥推导过程中私钥替换为公钥。
2. 子公钥推导出对应出与之的子链码

![](/publicFiles/images/BIP32-39-43-44/18473-a2e99449325ed852.png "子公钥推导")

#### 增强扩展密钥推导
密钥需加强保管以免泄漏，泄漏私钥意味着对应的地址上的币可被转走、泄漏公钥意味着 HD 钱包的隐私被泄漏。
增强密钥推导 (Hardened child key derivation) 解决下述两个问题：

1. 虽然泄漏公钥并不会导致丢币，但含有公钥的扩展密钥泄漏会导致以此为根节点推导出来的扩展公钥全部泄漏，一定程度上破坏了隐私性。
2. 泄漏扩展公钥加上该公钥推导出的后任一代扩展公钥对应的私钥有被推导出该扩展公钥的所有后代私钥的可能性
于此，BIP32 协议把 CKD 函数改为 HKD (hardened key derivation formula) 生成增强密钥推导函数。

CKD 函数以推导扩展密钥的序列号 ( 0x00 到 0x7fffffff)、父链码和父公钥生或父私钥成子链码和子公钥，子私钥从父私钥推导；而 HKD 通过父私钥、父链码和推导增强扩展密钥的序列号 (0x80000000 到 0xffffffff) 增强子私钥和增强子链码。

![](/publicFiles/images/BIP32-39-43-44/18473-f7dc4d2ecfdd1628.png "增强扩展密钥推导")


### BIP43 & BIP44 & BIP32

这俩真的没有什么好讲的。

**BIP43说: 我觉的32的结构想法是好的，但是我认为应该起个名字！**
**BIP44说: 对的，我建议叫 狗蛋！旺财！多福！**

仅此而已
