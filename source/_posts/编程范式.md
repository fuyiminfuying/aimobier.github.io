---
categories: 编程范式
title: 编程范式学习
tags:
  - 编程范式
  - 计算机语言基础
date: 2018-03-08 10:07:00
---
从事编程这么久，其实编程范式总还是听到很多的，比如 响应式，面向对象，面向过程.. 等等。今天打算整理一下这个东西，多半的资料都是在Wiki中看到的。

# 编程范型

**编程范型**或**编程范式**（英语：Programming paradigm），（**范**即模范之意，范式即模式、方法），是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。

编程范型提供了（同时决定了）程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列

正如软件工程中不同的群体会提倡不同的“方法学”一样，不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的（如Smalltalk和Java支持面向对象编程，而Haskell和Scheme则支持函数式编程），同时还有另一些语言支持多种范型（如Ruby、Common Lisp、Python和Oz）。

很多编程范型已经被熟知他们禁止使用哪些技术，同时允许使用哪些。例如，纯粹的函数式编程不允许有副作用；结构化编程不允许使用goto。可能是因为这个原因，新的范型常常被那些习惯于较早的风格的人认为是教条主义或过分严格。然而，这样避免某些技术反而更加证明了关于程序正确性——或仅仅是理解它的行为——的法则，而不用限制程序语言的一般性。

编程范型和编程语言之间的关系可能十分复杂，由于一个编程语言可以支持多种范型。例如，C++设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用C++写出一个完全过程化的程序，另一个人也可以用C++写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。

## 命令式编程

指令式编程（英语：Imperative programming），是一种描述电脑所需作出的行为的编程典范。几乎所有电脑的硬件工作都是指令式的；几乎所有电脑的硬件都是设计来运行机器码，使用指令式的风格来写的。较高级的指令式编程语言使用变量和更复杂的语句，但仍依从相同的典范。菜谱和行动清单，虽非计算机程序，但与指令式编程有相似的风格：每步都是指令，有形的世界控制情况。因为指令式编程的基础观念，不但概念上比较熟悉，而且较容易具体表现于硬件，所以大部分的编程语言都是指令式的。

大部分的高级语言都支持四种基本的语句：

1. **运算语句**一般来说都表现了在内存内的数据进行运算的行为，然后将结果存入内存中以便日后使用。高级指令式编程语言更能处理复杂的表达式，可能会产生四则运算和函数计算的结合。
2. **循环语句容许**一些语句反复运行数次。循环可依据一个默认的数目来决定运行这些语句的次数；或反复运行它们，直至某些条件改变。
3. **条件分支语句**容许仅当某些条件成立时才运行某个区块。否则，这个区块中的语句会略去，然后按区块后的语句继续运行。
4. **无条件分支语句**容许运行顺序转移到程序的其他部分之中。包括跳跃（在很多语言中称为Goto）、副程序和Procedure等。

循环、条件分支和无条件分支都是控制流程。

早期的指令式编程语言都是电脑本身的机械语言。在这些语言中，指示非常简单，令硬件的运行更容易，却阻碍了复杂程序的设计。1954年开始开发的FORTRAN，是首个在复杂程序的设计中除掉机器码的编程语言。它是编译型的编程语言，容许命名变量、复杂的表达式、副程序和其他功能，这些功能现在在指令式语言中都非常普遍。后来的二十年中，可以看到大量的其他高级指令式编程语言出现。在1980年后，面向对象编程有迅速的发展；面向对象编程语言均有着指令式的风格，但增添了支持对象的功能。

### 非结构化

非结构化程序设计是历史上最早的能够创造图灵完备算法的程序设计模式。在它之后，历史上又出现了结构化（过程化）程序设计、面向对象程序设计。

非结构化程序设计被批评最严重的方面就是会产生很难读懂的代码（戏称面条式代码），在创建大型工程方面有时会被认为是很差的，不过，因为赋予程序设计者很大的自由，被人称赞为如同莫扎特在谱曲。[1].

非结构化程序设计语言既有高级语言，也有低级语言。其中包括早期版本的BASIC（比如MSX BASIC和GW-BASIC）、JOSS、FOCAL、MUMPS、TELCOMP、COBOL、机器语言、早期的汇编语言（不包括过程化的metaoperators）、汇编调试器和一些脚本语言（比如MS-DOS batch文件语言）。

**基本概念**

一个使用非结构化语言的程序经常包含按顺序排列的命令或声明，通常每个都占用一行。每一行都有编号或者标签，这样程序中的任意行都可以被执行。

非结构化程序设计引入了基本控制流的概念，比如循环、分支和跳转。尽管在非结构化模式中不存在过程，不过子程序还是可以使用的。和过程不同，子程序可能有多个入口和出口。子程序中是允许直接跳转入或跳转出的。这种灵活性可以实现协同程序，而这在过程化程序设计中是相当困难以至于不可能的。

非结构化程序设计中是没有本地变量的概念的，不过标签和变量可以在有限的区域中起作用，比如，线组。这意味着在调用子程序时不需要上下文刷新，而所有的变量保持它们之前被调用后的值。这样，实现递归就很困难了。而嵌套的深度被限制在1或2级。

**数据类型**

非结构化语言只允许基本的数据类型，比如数字、字符串和数组（编号的同类型的变量集合）。尽管非结构化数据类型是被允许使用的，但是在将流数据处理前要注意先对数组定义进行声明。

#### 迭代

迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。

**在数学中**

数学中的迭代可以指函数迭代的过程，即反复地运用同一函数计算，前一次迭代得到的结果被用于作为下一次迭代的输入。即使是看上去很简单的函数，在经过迭代之后也可能产生复杂的行为，衍生出具有难度的问题。这样的例子可以参见考拉兹猜想和杂耍者序列（Juggler sequence）。又如一个简单的二次变换x→x(1-x)，它的迭代将形成一个具有混沌性质的动力系统。

迭代在数学中的另一应用是迭代法，用来对特定数学问题作数值解估计。牛顿法就是迭代法的一个例子。

**在计算机中**

在计算机科学中，迭代是程序中对一组指令（或一定步骤）的重复。它既可以被用作通用的术语（与“重复”同义），也可以用来描述一种特定形式的具有可变状态的重复。

在第一种意义下，递归是迭代的一个例子，但是通常使用一种递归式的表达。比如用0!=1，n!=n*(n-1)!来表示阶乘。而迭代通常不是这样写的。

而在第二种（更严格的）意义下，迭代描述了在指令式编程语言中使用的编程风格。与之形成对比的是递归，它更偏向于声明式的风格。

这里是一个依赖于破坏性赋值的迭代的例子，以指令式的虚拟码写成：

````js
 var i, a = 0        // 迭代前初始化
 for i from 1 to 3    // 循环3次
 {
     a = a + i       // a的值增加i
 }
 print a              // 打印出数字6

````
在这个程序片段中，变量i的值会不断改变，依次取值1、2和3。这种改变赋值——或者叫做可变状态——是迭代的特征。 这里是二分法解方程的递归和迭代算法的比较。 递归：
````
确定开区间左边界和右边界，(L, R)
若L + 1 >= R（即不包含整数点），表示序列中不存在f(x)
取中位 M = (L + R) / 2
若f(M) == y，返回M
否则根据f(M)和y的关系递归查找(L, M)或(M, R)
````
迭代:
````
确定边界(L, R)
while (L + 1 < R) /* 区间中包含整点 */
求中位M = (L + R) / 2
若f(M)等于y，退出循环
根据f(M)与y的关系执行 L = M 或 R = M，进入下一轮循环
````
在函数编程语言中，迭代可以用递归技巧来 下述例子用Scheme语言写成。注意它是一个递归（迭代的特例），因为函数iter在解决问题时调用了自身。特别地，它使用了尾部递归，一种能被Scheme这样的编程语言完备支持的技巧，因此程序不会占用大量堆栈。

````
;; sum : number -> number
;; to sum the first n natural numbers
(define(sum n)
  (if (and (integer? n) (> n 0))
     (let iter ([n n] [i 1])
       (if (= n 1)
            i
            (iter (- n 1) (+ n i))))
      ((assertion-violation
       'sum "invalid argument" n))))
````

迭代器（iterator）就是一个封装了迭代的对象。