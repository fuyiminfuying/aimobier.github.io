{"meta":{"title":"荆文征","subtitle":"已識乾坤大，猶憐草木新。","description":"欲买桂花同载酒<br/>终不似 少年游","author":"小酒馆老板","url":"http://www.msiter.com"},"pages":[{"title":"","date":"2017-11-28T11:07:04.827Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"404.html","permalink":"http://www.msiter.com/404.html","excerpt":"","text":""},{"title":"","date":"2017-11-28T11:07:04.835Z","updated":"2017-11-28T11:07:04.835Z","comments":true,"path":"themes_config.json","permalink":"http://www.msiter.com/themes_config.json","excerpt":"","text":"{\"override\":false,\"favicon\":{\"small\":\"favicon/favicon.png\",\"medium\":\"favicon/favicon.png\",\"apple_touch_icon\":\"favicon/favicon.png\",\"safari_pinned_tab\":\"favicon/favicon.png\"},\"keywords\":\"IOS,Swift,开发,技术,荆文征，博客,blog,msiter\",\"rss\":null,\"footer\":{\"icon\":\"user\",\"copyright\":false,\"powered\":false,\"theme\":{\"enable\":false,\"version\":false}},\"canonical\":true,\"seo\":true,\"index_with_subtitle\":true,\"menu\":{\"home\":\"/ || home\",\"tags\":\"/tags/ || tags\",\"categories\":\"/categories/ || th\",\"archives\":\"/archives/ || archive\"},\"menu_icons\":{\"enable\":true},\"scheme\":\"Pisces\",\"social_icons\":{\"enable\":true,\"icons_only\":false,\"transition\":false,\"GitHub\":\"github\",\"Twitter\":\"twitter\",\"Weibo\":\"weibo\"},\"links_icon\":\"link\",\"links_title\":\"Links\",\"links_layout\":\"block\",\"avatar\":\"favicon/avatar.jpg\",\"toc\":{\"enable\":true,\"number\":true,\"wrap\":false},\"sidebar\":{\"position\":\"left\",\"display\":\"post\",\"offset\":12,\"b2t\":true,\"scrollpercent\":false,\"onmobile\":false},\"scroll_to_more\":true,\"save_scroll\":false,\"excerpt_description\":true,\"auto_excerpt\":{\"enable\":false,\"length\":150},\"post_meta\":{\"item_text\":true,\"created_at\":true,\"updated_at\":false,\"categories\":true},\"post_wordcount\":{\"item_text\":true,\"wordcount\":false,\"min2read\":false,\"totalcount\":false,\"separated_meta\":true},\"post_copyright\":{\"enable\":false,\"license\":\"CC BY-NC-SA 3.0\",\"license_url\":\"https://creativecommons.org/licenses/by-nc-sa/3.0/\"},\"mobile_layout_economy\":false,\"android_chrome_color\":\"#222\",\"custom_logo\":{\"enabled\":false,\"image\":null},\"highlight_theme\":\"normal\",\"font\":{\"enable\":false,\"host\":null,\"global\":{\"external\":true,\"family\":\"Lato\",\"size\":null},\"headings\":{\"external\":true,\"family\":null,\"size\":null},\"posts\":{\"external\":true,\"family\":null},\"logo\":{\"external\":true,\"family\":null,\"size\":null},\"codes\":{\"external\":true,\"family\":null,\"size\":null}},\"mathjax\":{\"enable\":false,\"per_page\":false,\"cdn\":\"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML\"},\"han\":false,\"baidu_analytics\":\"37f9fd734b75f078c1b06452e6c3ccfb\",\"disqus\":{\"enable\":false,\"shortname\":\"msiter\",\"count\":true},\"changyan\":{\"enable\":true,\"appid\":\"cytc1YTze\",\"appkey\":\"4df84c3a0a2bad896b42860f7ed0a300\"},\"valine\":{\"enable\":false,\"appid\":null,\"appkey\":null,\"notify\":false,\"verify\":false,\"placeholder\":\"Comment input placeholder\"},\"gitment\":{\"enable\":false,\"mint\":true,\"count\":true,\"lazy\":false,\"cleanly\":false,\"language\":null,\"github_user\":null,\"github_repo\":null,\"client_id\":null,\"client_secret\":null,\"proxy_gateway\":null,\"redirect_protocol\":null},\"needmoreshare2\":{\"enable\":false,\"postbottom\":{\"enable\":false,\"options\":{\"iconStyle\":\"box\",\"boxForm\":\"horizontal\",\"position\":\"bottomCenter\",\"networks\":\"Weibo,Wechat,Douban,QQZone,Twitter,Facebook\"}},\"float\":{\"enable\":false,\"options\":{\"iconStyle\":\"box\",\"boxForm\":\"horizontal\",\"position\":\"middleRight\",\"networks\":\"Weibo,Wechat,Douban,QQZone,Twitter,Facebook\"}}},\"duoshuo_info\":{\"ua_enable\":true,\"admin_enable\":false,\"user_id\":0},\"facebook_sdk\":{\"enable\":false,\"app_id\":null,\"fb_admin\":null,\"like_button\":null,\"webmaster\":null},\"facebook_comments_plugin\":{\"enable\":false,\"num_of_posts\":10,\"width\":\"100%\",\"scheme\":\"light\"},\"vkontakte_api\":{\"enable\":false,\"app_id\":null,\"like\":true,\"comments\":true,\"num_of_posts\":10},\"rating\":{\"enable\":false,\"id\":null,\"color\":\"fc6423\"},\"leancloud_visitors\":{\"enable\":false,\"app_id\":null,\"app_key\":null},\"busuanzi_count\":{\"enable\":false,\"site_uv\":true,\"site_uv_header\":\"\",\"site_uv_footer\":null,\"site_pv\":true,\"site_pv_header\":\"\",\"site_pv_footer\":null,\"page_pv\":true,\"page_pv_header\":\"\",\"page_pv_footer\":null},\"baidu_push\":false,\"calendar\":{\"enable\":false,\"calendar_id\":\"\",\"api_key\":\"\",\"orderBy\":\"startTime\",\"offsetMax\":24,\"offsetMin\":4,\"timeZone\":null,\"showDeleted\":false,\"singleEvents\":true,\"maxResults\":250},\"algolia_search\":{\"enable\":false,\"hits\":{\"per_page\":10},\"labels\":{\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\",\"hits_stats\":\"${hits} results found in ${time} ms\"}},\"local_search\":{\"enable\":true,\"trigger\":\"auto\",\"top_n_per_article\":1},\"exturl\":false,\"note\":{\"style\":\"simple\",\"icons\":false,\"border_radius\":3,\"light_bg_offset\":0},\"label\":true,\"tabs\":{\"enable\":true,\"transition\":{\"tabs\":false,\"labels\":true},\"border_radius\":0},\"motion\":{\"enable\":true,\"async\":false,\"transition\":{\"post_block\":\"fadeIn\",\"post_header\":\"slideDownIn\",\"post_body\":\"slideDownIn\",\"coll_header\":\"slideLeftIn\",\"sidebar\":\"slideUpIn\"}},\"fancybox\":true,\"pace\":false,\"pace_theme\":\"pace-theme-minimal\",\"canvas_nest\":false,\"three_waves\":false,\"canvas_lines\":false,\"canvas_sphere\":false,\"canvas_ribbon\":{\"enable\":false,\"size\":300,\"alpha\":0.6,\"zIndex\":-1},\"vendors\":{\"_internal\":\"lib\",\"jquery\":null,\"fancybox\":null,\"fancybox_css\":null,\"fastclick\":null,\"lazyload\":null,\"velocity\":null,\"velocity_ui\":null,\"ua_parser\":null,\"fontawesome\":null,\"algolia_instant_js\":null,\"algolia_instant_css\":null,\"pace\":null,\"pace_css\":null,\"canvas_nest\":null,\"three\":null,\"three_waves\":null,\"canvas_lines\":null,\"canvas_sphere\":null,\"canvas_ribbon\":null,\"han\":null,\"needMoreShare2\":null},\"css\":\"css\",\"js\":\"js\",\"images\":\"images\",\"version\":\"5.1.3\"}"},{"title":"留言板","date":"2017-11-28T11:07:04.831Z","updated":"2017-11-28T11:07:04.831Z","comments":false,"path":"about/index.html","permalink":"http://www.msiter.com/about/index.html","excerpt":"","text":"I heard, that your settled down. 已闻君，诸事安康。That you, found a girl and your married now.遇佳人，不久婚嫁。I heard that your dreams came true. 已闻君，得偿所想。Guess she gave you things, I didn’t give to you. 料得是，卿识君望。Old friend, why are you so shy?旧日知己，何故张惶？It ain’t like you to hold back or hide from the lie.遮遮掩掩，欲盖弥彰。I hate to turn up out of the blue uninvited.客有不速，实非我所想。ButI couldn’t stay away, I couldn’t fight it. 避之不得，遑论与相抗。I’d hoped you’d see my face&amp; that you’d be reminded, 异日偶遇，识得依稀颜。That for me, it isn’t over.再无所求，涕零而泪下。Never mind, I’ll find someone like you. 毋须烦恼，终有弱水替沧海。I wish nothing but the best, for you too. 抛却纠缠，再把相思寄巫山。Don’t forget me, I beg, I remember you said:勿忘昨日，亦存君言于肺腑。“Sometimes it lasts in love but sometimes it hurts instead” “情堪隽永，也善心潮掀狂澜。”Sometimes it lasts in love but sometimes it hurts instead, yeah. 情堪隽永，也善心潮掀狂澜，然。You’d know, how the time flies.光阴常无踪，词穷不敢道荏苒。Only yesterday, was the time of our lives. 欢笑仍如昨，今却孤影忆花繁。We were born and raised in a summery haze. 彼时初执手，夏雾郁郁湿衣衫。Bound by the surprise of our glory days. 自缚旧念中，诧喜荣光永不黯。I hate to turn up out of the blue uninvited.客有不速，实非我所想。ButI couldn’t stay away, I couldn’t fight it. 避之不得，遑论与相抗。I’d hoped you’d see my face&amp; that you’d be reminded, 异日偶遇，识得依稀颜。That for me, it isn’t over.再无所求，涕零而泪下。 Nothing compares, no worries or cares. 无可与之相提，切莫忧心同挂念。Regret’s and mistakes they’re memories made. 糊涂遗恨难免，白璧微瑕方可恋。Who would have known how bittersweet this would taste? 此中酸甜苦咸，世上谁人堪相言？"},{"title":"类别","date":"2017-11-28T11:07:04.831Z","updated":"2017-11-28T11:07:04.831Z","comments":false,"path":"categories/index.html","permalink":"http://www.msiter.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-11-28T11:07:04.835Z","updated":"2017-11-28T11:07:04.835Z","comments":false,"path":"tags/index.html","permalink":"http://www.msiter.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"天通苑地铁 安检方式改变","slug":"生活随处可见一斑20171123","date":"2017-11-23T09:18:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/11/23/生活随处可见一斑20171123/","link":"","permalink":"http://www.msiter.com/2017/11/23/生活随处可见一斑20171123/","excerpt":"今天早上来到天通苑地铁站发现安检方式改变了，以前是一个口安检，在大门口存在一个可以供没带包乘客进入的通道，由于这个口离安检人员较远甚至存在一个弯道，所以根本没人会管带包乘客进入该通道。后来通道干脆封掉了，这样一来，带包不带包都需要在一个地方排队等待安检了。现在在原本通道的地方放置了两个安检门把有包无包区分开来。我只是觉得这样子挺好的，本着生活处处皆学问的心理自己觉得大概有几种心理导致了以上描述","text":"今天早上来到天通苑地铁站发现安检方式改变了，以前是一个口安检，在大门口存在一个可以供没带包乘客进入的通道，由于这个口离安检人员较远甚至存在一个弯道，所以根本没人会管带包乘客进入该通道。后来通道干脆封掉了，这样一来，带包不带包都需要在一个地方排队等待安检了。现在在原本通道的地方放置了两个安检门把有包无包区分开来。我只是觉得这样子挺好的，本着生活处处皆学问的心理自己觉得大概有几种心理导致了以上描述 最开始人们在没有人注意的时候会走通道，另外就是当一个带包的人走之后。所有的人都会出现这种情况，这种情况就类似一个很干净的地方，被一个人丢了垃圾，那里就会不断被人丢垃圾，直到变成垃圾桶。这种心理很多，从众，羊群，我觉得最好的是 破窗定律。 破窗效应，是关于环境对人们心理造成暗示性或诱导性影响的一种认识。指如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些暗示性的纵容去打烂更多的窗户。一个房子如果窗户破了，没有人去修补，隔不久，其它的窗户也会莫名其妙地被人打破；一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一个很干净的地方，人们不好意思丢垃圾，但是一旦地上有垃圾出现之后，人就会毫不犹豫地抛，丝毫不觉羞愧。一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有 破坏者 破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是犯罪心理学中的破窗效应。 而现在的处理方式则是利用的是，自我焦点效应，在众目睽睽之下，尤其是在安检人员和乘客不太出现那种无视规则的人，除非… 自我焦点效应,spotlight effect ，也叫做社会焦点效应，是人们 高估 周围人对自己外表和行为关注度的一种表现。焦点效应意味着人类往往会把自己看作一切的中心，并且直觉地高估别人对我们的注意程度。焦点效应其实是 每个人都会 有的体验，这种心理状态让我们过度关注自我，过分在意聚会或者工作集会时周围人们对我们的关注程度。国外有实验和结论的,大体就是除非你不穿衣服,或者在讲和做那些引人注意的事(通常跟性,死亡有关)即使你穿的像只猴子或者漂亮的像只孔雀,也么有几个人会留意你，大家都是看的自己,同时希望别人看自己. 生活处处皆学问，不得不说其实厉害的人无处不在。 很多人有仇视社会，自己如何努力都能做到一些事情，而觉得社会不公，觉得自己就是基于不到，以下是我辍学工作这么多年体会得到一些点可以一起分享下 在互联网看到的内容来源于你想看到的内容。 上学有没有用我不知道，我只知道学历比我高的人他看问题比我快准狠，我指的是“学成” 楼下一个男人病得要死，那间壁的一家唱着留声机，对面是弄孩子。墙上有两个人狂笑，还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只是觉得他们吵闹。 鲁迅 - 《而已集》 当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。 陶杰-《杀鹌鹑的少女》 一下再也想不起来这么多了 以后慢慢补充吧。 热爱生活，有时候等待回报的时候不要自暴自弃，在这段时间不如多学习！🎉🎉🎉🎉","categories":[{"name":"生活","slug":"生活","permalink":"http://www.msiter.com/categories/生活/"}],"tags":[{"name":"无趣，心理学","slug":"无趣，心理学","permalink":"http://www.msiter.com/tags/无趣，心理学/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://www.msiter.com/categories/生活/"}]},{"title":"使用 NodeJS APNS 给你的应用发消息","slug":"使用 NodeJS APNS 给你的应用发消息","date":"2017-11-22T17:02:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/11/22/使用 NodeJS APNS 给你的应用发消息/","link":"","permalink":"http://www.msiter.com/2017/11/22/使用 NodeJS APNS 给你的应用发消息/","excerpt":"用到了小米的 MiPushSDK 今天出现了问题，总之无论如何就吃错误。在跟他们的开发人员进行交流的同时，我想看看是谁的问题，所以有了以下的经历。","text":"用到了小米的 MiPushSDK 今天出现了问题，总之无论如何就吃错误。在跟他们的开发人员进行交流的同时，我想看看是谁的问题，所以有了以下的经历。 创建推送证书创建推送证书 这个步骤省略 导出 证书.p12 和 key.p12推送证书安装在本地之后 打开 应用 钥匙串访问 找到自己的证书 在需要导出的证书上右键点击 导出 这个东西就是证书.p12 有没有密码都可以 密码会用来一会 openssl 的时候输入 点击这个证书 展开之后会看到一个 Key 右键导出 这个导出的 p12 就是 key.p12 密码设置同上 将导出的 p12 生成为 pemopenssl pkcs12 -clcerts -nokeys -out cert.pem -in cert.p12 # 导出 cert.pem openssl pkcs12 -in key.p12 -out key.pem -nodes # 导出 key.pem 在转换过程中 p12 设置了密码就输入密码 没有输入直接回车就可以在设置 key.pem 的过程中 会向你询问是否设置密码，设置密码需要输入两次 分别是密码和确认密码 开始创建 Nodejs APNS 服务创建 NodeJs项目创建一个 NodeJS 项目 mkdir APNS cd APNS npm init 按照步骤填写信息，之后在生成的package.json 文件中 引入 对于 apn 的支持 \"dependencies\": { \"apn\": \"\" } 总体上看起来是这个样子的 { \"name\": \"apn\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"apn\": \"\" } } 完成创建一个 index.js 文件 var apn = require(\"apn\"); var tokens = [\"&lt;&lt;you want push device token>>\"]; var service = new apn.Provider({ \"cert\": \"push/cert.pem\", // 根目录下创建 push 文件夹 将文件放置在内，当然你可以放在自己喜欢的位置 \"key\": \"push/key.pem\", \"production\":false }); var note = new apn.Notification({ \"alert\":\"Hello World!\", \"sound\":\"default\" }); // The topic is usually the bundle identifier of your application. note.topic = \"&lt;&lt;you bundle identifier>>\"; note.badge = 0; console.log(`Sending: ${note.compile()} to ${tokens}`); service.send(note, tokens).then( result => { console.log(\"sent:\", result.sent.length); console.log(\"failed:\", result.failed.length); console.log(result.failed); }); // For one-shot notification tasks you may wish to shutdown the connection // after everything is sent, but only call shutdown if you need your // application to terminate. service.shutdown(); 这里面只进行了一些基本的设置，只设置了标题关于消息内容等设置 可以查阅文档或者直接在 apn/lib/notification/ 目录下查看 设置 目前的版本是存在这些的 [\"payload\", \"expiry\", \"priority\", \"alert\", \"body\", \"locKey\", \"locArgs\", \"title\", \"subtitle\", \"titleLocKey\", \"titleLocArgs\", \"action\", \"actionLocKey\", \"launchImage\", \"badge\", \"sound\", \"contentAvailable\", \"mutableContent\", \"mdm\", \"urlArgs\", \"category\", \"threadId\"] 测试node index.js 大功告成","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://www.msiter.com/tags/NodeJS/"},{"name":"APNs","slug":"APNs","permalink":"http://www.msiter.com/tags/APNs/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}]},{"title":"IOS10前 UITextFiled 的 placeholder 的问题","slug":"IOS10前 UITextFiled 的 placeholder 的问题","date":"2017-11-16T01:16:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/11/16/IOS10前 UITextFiled 的 placeholder 的问题/","link":"","permalink":"http://www.msiter.com/2017/11/16/IOS10前 UITextFiled 的 placeholder 的问题/","excerpt":"The styled string that is displayed when there is no other text in the text field.This property is nil by default. If set, the placeholder string is drawn using system-defined color and the remaining style information (except the text color) of the attributed string. Assigning a new value to this property also replaces the value of the placeholder property with the same string data, albeit without any formatting information. Assigning a new value to this property does not affect any other style-related properties of the text field 这是官方的一片解释，看着都很不错的～","text":"The styled string that is displayed when there is no other text in the text field.This property is nil by default. If set, the placeholder string is drawn using system-defined color and the remaining style information (except the text color) of the attributed string. Assigning a new value to this property also replaces the value of the placeholder property with the same string data, albeit without any formatting information. Assigning a new value to this property does not affect any other style-related properties of the text field 这是官方的一片解释，看着都很不错的～ 然而 今天我们的巨头设计师来找我，说我的输入框不居中.我不以为然，怎么可能～因为我的设备上是好的拿来手机一看，还真是，，，好吧 赶紧找原因吧，因为我的设备是IOS11 所以我怀疑是不是IOS10的问题。之后找了一些资料发现 Vertically centering a UITextField’s attributedPlaceholderuitextfield attributedplaceholder center Google 发觉这个问题还是普遍存在的 有不少人给处理自己的做法比如： kean在 Stackflow中的回答 NSMutableParagraphStyle *style = [self.addressBar.defaultTextAttributes[NSParagraphStyleAttributeName] mutableCopy]; style.minimumLineHeight = self.addressBar.font.lineHeight - (self.addressBar.font.lineHeight - [UIFont fontWithName:@\"Gotham-BookItalic\" size:14.0].lineHeight) / 2.0; self.addressBar.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@\"Placeholder text\" attributes:@{ NSForegroundColorAttributeName: [UIColor colorWithRed:79/255.0f green:79/255.0f blue:79/255.0f alpha:0.5f], NSFontAttributeName : [UIFont fontWithName:@\"Gotham-BookItalic\" size:14.0], NSParagraphStyleAttributeName : style } ]; 另外他也给出了另一种方法 You could also override a - (CGRect)placeholderRectForBounds:(CGRect)bounds; method in UITextField subclass. It’s messy, but it works :) 还有很多搜到的方法 我就不一一赘述了。他们的方法或多或少的都没很麻烦，而且需要进行适配，比如这种调整位置的是可以的。但是IOS11 位置又好了怎么办呢？最终找到如下的方法，特此记录一下 - (CGRect)placeholderRectForBounds:(CGRect)bounds { return CGRectMake(0, 0 , self.bounds.size.width, self.bounds.size.height); } - (void)drawPlaceholderInRect:(CGRect)rect { [super drawPlaceholderInRect:CGRectMake(0, 0 , self.bounds.size.width, self.bounds.size.height)]; }","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/tags/IOS/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"WebView 与 Html Input File 以及 Upload File 出现的问题","slug":"WebView 与 Html Input Bug","date":"2017-10-26T04:10:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/10/26/WebView 与 Html Input Bug/","link":"","permalink":"http://www.msiter.com/2017/10/26/WebView 与 Html Input Bug/","excerpt":"在项目中使用了WebView来显示一些内容，之后就遇到了一些问题。总结了一下","text":"在项目中使用了WebView来显示一些内容，之后就遇到了一些问题。总结了一下 遇到 Input File 出现的 崩溃问题这个问题其实还是比较好解决 无非就是权限问题 具体的key值 请直接访问 Cocoa Keys Model 的ViewController 在上传文件后 会直接 dismiss掉解决办法 在 Model 出来的 ViewController 加入 UINavigationController 之后重写 UINavigationController 的方法 -(void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion{ if (self.presentedViewController) { [super dismissViewControllerAnimated:flag completion:completion]; } } 自己重写pan dismiss 方法的障碍解决在我们想重写dismiss的方法时，会绑定一个手势。但是在 WebView中已经存在了很多手势了。其中就包括 两个 UIScreenEdgePanGestureRecognizer，一个进行前进操作 一个进行后退操作 我们想重写pan方法进行前进后退dismiss的话，暂时只有两种办法，接下来我们看看那种方法可以使用吧 第一种 自己去写 WebView 中的 pan 手势首先想到的就是这个方法，因为这个方法很省事儿，可定义程度高，当然这是可行的情况下 事实证明，我们在第一个问题就被拌住了，我们没有办法去渐进式的 前进网页 和 后退 所以这个问题不得不放弃 第二种 使用 UIGestureRecognizerDelegate 来暂时关闭 webview中的手势这个方法最终实践是可以的 首先我们获取到 后退的手势 在创建 WebView 之后，我们这样获取 获取到 手势 并且设置 delegatefor (UIGestureRecognizer *reconizer in self.wkWebView.gestureRecognizers) { /// 如果获取的 手势 类型是 ScreenEdgePanGestureRecognizer 类型 if ([reconizer isKindOfClass:UIScreenEdgePanGestureRecognizer.class] ) { /// 如果手势对象是 返回的收视对象 作出以下处理 if (((UIScreenEdgePanGestureRecognizer*)reconizer).edges == UIRectEdgeLeft) { reconizer.delegate = self; } /// 该手势就是 前进手势 if (((UIScreenEdgePanGestureRecognizer*)reconizer).edges == UIRectEdgeRight) { } } } 根据WebView 是否可以返回 控制手势是否可用获取到 delegate之后我们就可以进行操作了 接下来实现 delegate 的方法 /// 当WebView 不可以返回到时候，我们不让该手势触发 -(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{ return self.wkWebView.canGoBack; } 写 推出视图的方法-(instancetype)initWithRootViewController:(UIViewController *)rootViewController{ self = [super initWithRootViewController:rootViewController]; if (self) { _presentdAnimation = [[BaseViewControllerPresentdAnimation alloc] init]; _dismissedAnimation = [[BaseViewControllerDismissedAnimation alloc] init]; _interactiveTransitioning = [[BasePresentdAnimationInteractiveTransition alloc]init]; self.navigationBarHidden = true; self.transitioningDelegate = self; self.modalPresentationCapturesStatusBarAppearance = true; /// 在获取到 RootViewController 完成 手势的绑定 这样在 Wkwebview 手势不可用的时候 该手势就可以使用了 _panGestureRecognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanGestureRecognizerMethod:)]; _panGestureRecognizer.edges = UIRectEdgeLeft; [rootViewController.view addGestureRecognizer:_panGestureRecognizer]; } return self; } -(id&lt;UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{ return _presentdAnimation ; } -(id&lt;UIViewControllerAnimatedTransitioning>)animationControllerForDismissedController:(UIViewController *)dismissed{ return _dismissedAnimation; } -(id&lt;UIViewControllerInteractiveTransitioning>)interactionControllerForDismissal:(id&lt;UIViewControllerAnimatedTransitioning>)animator{ if (_dismissedAnimation.isInteraction) { return _interactiveTransitioning; } return nil; } -(void)handlePanGestureRecognizerMethod:(UIPanGestureRecognizer *)pan{ CGPoint point = [pan translationInView:self.view]; switch (pan.state) { case UIGestureRecognizerStateBegan: self.dismissedAnimation.isInteraction = true; [self.viewControllers.firstObject dismissViewControllerAnimated:true completion:nil]; break; case UIGestureRecognizerStateChanged: [_interactiveTransitioning updateInteractiveTransition: (CGFloat)point.x/CGRectGetWidth(self.view.frame)]; break; default: _dismissedAnimation.isInteraction = false; CGFloat locationX = ABS(point.x); CGFloat velocityX = [pan velocityInView:self.view].x; if (velocityX >= 500 || locationX >= CGRectGetWidth(self.view.frame)/2) { [_interactiveTransitioning finishInteractiveTransition]; }else{ [_interactiveTransitioning cancelInteractiveTransition]; } break; } } 效果如下：","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"WKWebView","slug":"WKWebView","permalink":"http://www.msiter.com/tags/WKWebView/"},{"name":"WebView","slug":"WebView","permalink":"http://www.msiter.com/tags/WebView/"},{"name":"UIWebView","slug":"UIWebView","permalink":"http://www.msiter.com/tags/UIWebView/"},{"name":"Input","slug":"Input","permalink":"http://www.msiter.com/tags/Input/"},{"name":"File","slug":"File","permalink":"http://www.msiter.com/tags/File/"},{"name":"Bug","slug":"Bug","permalink":"http://www.msiter.com/tags/Bug/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"IOS shadowColor 动画 卡顿","slug":"IOS shadowColor 动画 卡顿","date":"2017-10-12T18:00:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/10/12/IOS shadowColor 动画 卡顿/","link":"","permalink":"http://www.msiter.com/2017/10/12/IOS shadowColor 动画 卡顿/","excerpt":"最近开发的时候遇见了一件怪事儿，做了一个 UIViewControllerContextTransitioning,在同事的手机上跳转会卡顿。在此之前写的跳转动画都没有卡顿的现象。最终终于发现了问题的所在在于 shadowColor ，在跳转的时候我设置了一个阴影增加层级层次效果。","text":"最近开发的时候遇见了一件怪事儿，做了一个 UIViewControllerContextTransitioning,在同事的手机上跳转会卡顿。在此之前写的跳转动画都没有卡顿的现象。最终终于发现了问题的所在在于 shadowColor ，在跳转的时候我设置了一个阴影增加层级层次效果。 @implementation BaseViewControllerPresentdAnimation -(NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning>)transitionContext { return 0.5; } -(void)animateTransition:(id&lt;UIViewControllerContextTransitioning>)transitionContext{ UIViewController *toViewController = [transitionContext viewControllerForKey:(UITransitionContextToViewControllerKey)]; UIView *containerView = [transitionContext containerView]; UIView *coverView = [UIView.alloc initWithFrame:containerView.bounds]; coverView.backgroundColor = [UIColor.blackColor colorWithAlphaComponent:0]; [containerView addSubview:coverView]; toViewController.view.transform = CGAffineTransformTranslate(toViewController.view.transform, CGRectGetWidth(toViewController.view.frame), 0); [containerView addSubview:toViewController.view]; [self makeShadowMethod:toViewController]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ toViewController.view.transform = CGAffineTransformIdentity; coverView.backgroundColor = [UIColor.blackColor colorWithAlphaComponent:0.3]; } completion:^(BOOL finished) { [coverView removeFromSuperview]; [transitionContext completeTransition:true]; }]; } -(void)makeShadowMethod:(UIViewController *)toViewController{ toViewController.view.clipsToBounds = false; /// 需要添加这句话，可以使动画不再卡顿 toViewController.view.layer.shadowPath = [UIBezierPath bezierPathWithRect:toViewController.view.bounds].CGPath; toViewController.view.layer.shadowRadius = 2; toViewController.view.layer.shadowColor = [UIColor.blackColor colorWithAlphaComponent:0.4].CGColor; toViewController.view.layer.shadowOffset = CGSizeMake(-3.0f,0); toViewController.view.layer.shadowOpacity = 0.4; } @end 知道这个解决方案是看到了 Lu_Ca的博客 之后就很好奇为什么这个代码会有这么神奇的作用呢？ SpeedBoy007的专栏 只要你提前告诉CoreAnimation你要渲染的View的形状Shape,就会减少离屏渲染计算 [myView.layer setShadowPath：[[UIBezierPath bezierPathWithRect：myView.bounds] CGPath]; 加上这行代码，就减少离屏渲染时间，大大提高了性能","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.msiter.com/tags/Objective-C/"},{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"一杯敬自由，一杯敬死亡","slug":"2017-9-4 有感","date":"2017-09-04T03:25:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/09/04/2017-9-4 有感/","link":"","permalink":"http://www.msiter.com/2017/09/04/2017-9-4 有感/","excerpt":"","text":"转眼二十多年过去了，今年22岁，身高178，体重145斤。这两年，体重没有变高，但是体重和年龄确实变大了不少，身体变弱了很多，出去玩的时候，稍微运动下，第二天身体就会给出非常明显的反应，酸痛感十足 可怕的不是变大了，身体变差了，而是默默的接受了这各种设定，给自己一个改变不了的理由了。 这些年，在北京，从最开始的创业公司遍天下，到现在的寥寥数几个。看惯了，失败，看惯了，别人的成功。看惯了以前看不惯的 变老的不只是身体，更多的是那份心。 以前不知道的知道，但是少了的是，时间，拼，劲儿，其实归根结底还是对于目前的不敢放弃，从头来，也许会更好，但是不敢再去试验了。 当你走进这欢乐场背上所有的梦与想各色的脸上各色的妆没人记得你的模样三巡酒过你在角落固执的唱着苦涩的歌听他在喧嚣里被淹没你拿起酒杯对自己说一杯敬朝阳，一杯敬月光唤醒我的向往，温柔了寒窗于是可以不回头的逆风飞翔不怕心头有雨，眼底有霜一杯敬故乡，一杯敬远方守着我的善良，催着我成长所以南北的路从此不再漫长灵魂不再无处安放一杯敬明天，一杯敬过往支撑我的身体，厚重了肩膀虽然从不相信所谓山高水长人生苦短何必念念不忘一杯敬自由，一杯敬死亡宽恕我的平凡，驱散了迷惘好吧天亮之后总是潦草离场清醒的人最荒唐好吧天亮之后总是潦草离场清醒的人最荒唐 是对还是错，其实你知道的，只是不敢","categories":[{"name":"牢骚","slug":"牢骚","permalink":"http://www.msiter.com/categories/牢骚/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.msiter.com/tags/生活/"},{"name":"悲观","slug":"悲观","permalink":"http://www.msiter.com/tags/悲观/"}],"keywords":[{"name":"牢骚","slug":"牢骚","permalink":"http://www.msiter.com/categories/牢骚/"}]},{"title":"AsyncDisplayKit 2.1 Gif错误，以及解决方法","slug":"AsyncDisplayKit 2.1 Gif错误","date":"2017-08-22T14:45:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/08/22/AsyncDisplayKit 2.1 Gif错误/","link":"","permalink":"http://www.msiter.com/2017/08/22/AsyncDisplayKit 2.1 Gif错误/","excerpt":"在使用 AsyncDisplayKit 遇到了一些问题，因为工作需要必须支持IOS7，所以选择了 AsyncDisplayKit 2.1版本。但是在使用 其中的 展示gif的时候出现了一些问题。","text":"在使用 AsyncDisplayKit 遇到了一些问题，因为工作需要必须支持IOS7，所以选择了 AsyncDisplayKit 2.1版本。但是在使用 其中的 展示gif的时候出现了一些问题。 目前的 修改库 版本为 在使用的时候出现了 GIF 有的时候出现，有的是不出现，有的时候出现了，却不动的情况。 最终找到解决方案在。 AsyncDisplayKit Pull Request 3057 代码在于 AsyncDisplayKit commit d270577f23dca63c69bc6cd0e4cea6652733a376 但是现在 AsyncDisokayKit 已经开始支持 IOS8版本以上了。并且已经移动到了 Texture 所以我们只能手动自己创建了一个版本了。 解决方案 自己本地 local 库 修改 2.1 版本的代码 使用我已经修改好的代码库 引入 pod AsyncDisplayKitFix —————————————— 2017年9月4号 再次修复了，两个问题，当然只是我的项目中的。记录一下 第一个. 关于 ASTableNode 刷新某一个section或者某一个行的时候，会启动一个验证方法，但是这个方法是验证所有的section，我分别控制第一个或者第二个secrion就会出现刷新前和刷新后的数量对不上，而导致报错。 在文件 _ASHierarchyChangeSet.mm _validateUpdate 修改验证 第二个. 在ASTextNode赋值的时候，我记得没错误的话。官方的例子是 可以判断 ASTextNode的attritedString 是否为空，来做一些布局的变化。但是在实际使用中，发现了它的方法，写的确实 - (void)setAttributedText:(NSAttributedString *)attributedText { if (attributedText == nil) { attributedText = [[NSAttributedString alloc] initWithString:@\"\" attributes:nil]; } // Don't hold textLock for too long. { ASDN::MutexLocker l(__instanceLock__); if (ASObjectIsEqual(attributedText, _attributedText)) { return; } 这种问题就是会一直都不能为nil。故而修复为 - (void)setAttributedText:(NSAttributedString *)attributedText { if (attributedText == nil) { return; } // Don't hold textLock for too long. { ASDN::MutexLocker l(__instanceLock__); if (ASObjectIsEqual(attributedText, _attributedText)) { return; }","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.msiter.com/tags/Objective-C/"},{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://www.msiter.com/tags/AsyncDisplayKit/"},{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"约束教程","slug":"约束教程","permalink":"http://www.msiter.com/tags/约束教程/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"Spring boot Mybatis 学习","slug":"Spring boot Mybatis 学习","date":"2017-07-21T18:25:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/07/21/Spring boot Mybatis 学习/","link":"","permalink":"http://www.msiter.com/2017/07/21/Spring boot Mybatis 学习/","excerpt":"开始前的闲聊一直都想回家，北京呆不起。想回家，却发现，家里的开发职位都是java的，，，那没办法，捡起来吧","text":"开始前的闲聊一直都想回家，北京呆不起。想回家，却发现，家里的开发职位都是java的，，，那没办法，捡起来吧 基本设置在创建项目的时候，我们使用了最基本的配置，所以项目没有目录等。我们需要使用maven默认的文件配置 src main -- 开发包 java -- 代码包 resources -- 资源包 test -- 测试包 java -- 代码包 resources -- 资源包 gradle 配置在idea 创建一个 gradle 项目。但是本来在本地安装了一个 4.0 版本的 gradle，我在idea设置了一个 local gradle，但是却出现了一个问题。 启动服务器的时候，出现了莫名的问题最后在statckflow中发现了解决办法就是使用默认的gradle。 之后配置 gradle 安装信息 group &#39;Farrom&#39; version &#39;1.0-SNAPSHOT&#39; apply plugin: &#39;java&#39; apply plugin: &#39;war&#39; apply plugin: &#39;idea&#39; sourceCompatibility = 1.8 repositories { jcenter() maven { url &quot;http://repo.spring.io/snapshot&quot; } maven { url &quot;http://repo.spring.io/milestone&quot; } } dependencies { // 阿里巴巴 durid 数据源 compile group: &#39;com.alibaba&#39;, name: &#39;druid&#39;, version: &#39;1.1.1&#39; // 数据 链接 compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;6.0.6&#39; // Spring Boot compile group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;1.5.4.RELEASE&#39; // Mybatis compile group: &#39;org.mybatis&#39;, name: &#39;mybatis&#39;, version: &#39;3.4.4&#39; compile group: &#39;org.mybatis&#39;, name: &#39;mybatis-spring&#39;, version: &#39;1.3.1&#39; compile group: &#39;org.mybatis.spring.boot&#39;, name: &#39;mybatis-spring-boot-starter&#39;, version: &#39;1.3.0&#39; } 创建 Spring 配置文件name: Demo server: port: 8090 datasource: url: jdbc:mysql://localhost:3306/parrom?autoReconnect=true&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: 123456 driverClassName: com.mysql.jdbc.Driver mybatis: typeAliasesPackage: com.farrom.domain package com.farrom.config; import com.alibaba.druid.pool.DruidDataSourceFactory; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; import java.util.Properties; @Configuration @EnableTransactionManagement public class MybatisConfig { @Value(\"${datasource.url}\") private String url; @Value(\"${datasource.driverClassName}\") private String driverClassName; @Value(\"${datasource.username}\") private String username; @Value(\"${datasource.password}\") private String password; @Value(\"${mybatis.typeAliasesPackage}\") private String typeAliasesPackage; /** * 创建数据源 * @Primary 该注解表示在同一个接口有多个实现类可以注入的时候，默认选择哪一个，而不是让@autowire注解报错 */ @Bean public DataSource getDataSource() throws Exception{ Properties props = new Properties(); // props.put(\"driverClassName\", this.driverClassName); ##Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. props.put(\"url\", this.url); props.put(\"username\", this.username); props.put(\"password\", this.password); return DruidDataSourceFactory.createDataSource(props); } /** * 根据数据源创建SqlSessionFactory */ @Bean(name=\"sqlSessionFactory\") public SqlSessionFactory sqlSessionFactory() throws Exception { SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean(); sqlSessionFactory.setDataSource(this.getDataSource()); return sqlSessionFactory.getObject(); } } 数据库 emoji mysql 适配。在根目录下的etc创建一个文件,my.cnf。在文件中设置配置 [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] character-set-client-handshake=FALSE character-set-server=utf8mb4 collation-server=utf8mb4_unicode_ci init-connect=&#39;SET NAMES utf8mb4&#39; 创建Database的时候选择 对一个的编码 该配置不需要设置任何代码。这个时候 sqlsession就已经创建好了 目前就学习了这点。。。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.msiter.com/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://www.msiter.com/tags/spring-boot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://www.msiter.com/tags/mybatis/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}]},{"title":"Charles version 4.1 破解 以及 Https 的破译","slug":"charles 4.1 破解","date":"2017-07-10T13:26:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/07/10/charles 4.1 破解/","link":"","permalink":"http://www.msiter.com/2017/07/10/charles 4.1 破解/","excerpt":"Charles 限时优惠Charles 4 正版限时优惠优惠活动（限时：2016 年 8 月 8 日 - 15 日），优惠 30 元，点击领取优惠券。 简介 Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。","text":"Charles 限时优惠Charles 4 正版限时优惠优惠活动（限时：2016 年 8 月 8 日 - 15 日），优惠 30 元，点击领取优惠券。 简介 Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 Charles 4 新增的主要功能包括： 支持 Http 2。 支持 IPv6。 安装 Charles去 Charles 的官方网站（http://www.charlesproxy.com）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。 将 Charles 设置成系统代理之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。 启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 Charles 主界面介绍 Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 Structure 视图将网络请求按访问的域名分类。 Sequence 视图将网络请求按访问的时间排序。 大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。 对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。 过滤网络请求通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法： 方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuantiku.com , 那么只需要在 Filter 栏中填入 yuantiku 即可。 方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示： 通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。 方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。 截取 iPhone 上的网络封包Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。 Charles 上的设置要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示: iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示： 在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示： 设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。 截取 Https 通讯信息安装证书如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。 首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示： 需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示： 这样，对于该 Host 的所有 SSL 请求可以被截取到了。 截取移动设备中的 Https 通讯信息如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示： 按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。 模拟慢速网络在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示： 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示： 我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示： 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。 我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示： 接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。 修改服务器返回内容有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map 功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 www.yuantiku.com（线上服务器）。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。 下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示： 我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则： 完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示： Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。 Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。 下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。 需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 反向代理Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上。例如，在下图中，我将本机的 61234 端口映射到了远程（www.yuantiku.com）的80端口上了。这样，当我访问本地的 61234 端口时，实际返回的内容会由 www.yuantiku.com 的 80 端口提供。 设置外部代理，解决与翻墙软件的冲突Charles 的原理是把自己设置成系统的代理服务器，但是在中国，由于工作需要，我们常常需要使用 Google 搜索，所以大部分程序员都有自己的翻墙软件，而这些软件的基本原理，也是把自己设置成系统的代理服务器，来做到透明的翻墙。 为了使得两者能够和平共处，我们可以在 Charles 的 External Proxy Settings 中，设置翻墙的代理端口以及相关信息。同时，我们也要关闭相关翻墙软件的自动设置，使其不主动修改系统代理，避免 Charles 失效。 破解 下载特定的版本的Charles以及破解文件 charles.jar 在应用程序中右键Charles，选择“显示包内容”。 依次打开目录：Contents -&gt; Java 用下载的charles.jar替换目录中的charles.jar。 重新打开后还是破解失败的所以需要 点击 Help -&gt; Register Charles 随便输入即可破解完成 总结通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。 愿本文帮助大家成为 Charles 的专家，祝大家玩得开心～ 本文全部引用自 唐巧的 Charles 从入门到精通","categories":[{"name":"开发帮助","slug":"开发帮助","permalink":"http://www.msiter.com/categories/开发帮助/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"约束教程","slug":"约束教程","permalink":"http://www.msiter.com/tags/约束教程/"},{"name":"破解","slug":"破解","permalink":"http://www.msiter.com/tags/破解/"},{"name":"抓包","slug":"抓包","permalink":"http://www.msiter.com/tags/抓包/"}],"keywords":[{"name":"开发帮助","slug":"开发帮助","permalink":"http://www.msiter.com/categories/开发帮助/"}]},{"title":"travis-ci 来维护 Cocoapods","slug":"travis-ci 来维护 Cocoapods","date":"2017-05-25T18:54:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/05/25/travis-ci 来维护 Cocoapods/","link":"","permalink":"http://www.msiter.com/2017/05/25/travis-ci 来维护 Cocoapods/","excerpt":"","text":"教程开始前的废话连篇我们公司的app，是在是火不聊了。那么办法了，我们抽象出来一个sdk给别人接吧。这样子的话，我们怎么也可以有些量啊。 最开始使用的Cocoapods 全部代码开发的方式来制作的，在跨过一个又一个的大坑之后，终于到了，要把代码达成 .a 包地步，其实是可以达成 .framework 的。主要是还是因为代码需要兼容 ios 7 。所以必须要使用 达成 static 的方式。 打包首先使用的打包命令，肯定是 xcodebuild 不要问我，如何使用，google吧。 我们使用的命令时 xcodebuild build -project Pods/Pods.xcodeproj -target OddityOcUI 这样子打下来是默认 Iphone sdk版本+realese 版本的，这样子只在真机上运行肯定是没问题啦～ 但是你怎么都得做到可以在模拟器上跑吧。所以就需要接下来的这一句了。 xcodebuild build -project Pods/Pods.xcodeproj -target OddityOcUI -sdk iphonesimulator10.3 后面的是 sdk 版本，不知道版本的可以运行命令 xcodebuild -showsdks 现在开始整合 travis-ci既然都找到这里了，我就不跟你bb那么多了。其实我们最多不会写 yml文件嘛。 因为 budild 会遇见非常多的log，我为了解决，尝试使用了。xcpretty 事实证明…… 没啥用处。先放着吧。 language: objective-c osx_image: xcode8.3 os: - osx branches: only: - master before_install: - gem install xcpretty install: - pod install --repo-update before_script: - git config --global user.name \"\" - git config --global user.email \"\" - git clone ${CocoaPodsRepo} script: - set -o pipefail &amp;&amp; xcodebuild build -project Pods/Pods.xcodeproj -target OddityOcUI | xcpretty -c - set -o pipefail &amp;&amp; xcodebuild build -project Pods/Pods.xcodeproj -target OddityOcUI -sdk iphonesimulator10.3 | xcpretty -c - lipo -create build/Release-iphoneos/OddityOcUI/libOddityOcUI.a build/Release-iphonesimulator/OddityOcUI/libOddityOcUI.a -output libOddityOcUI.a after_success: - bash operation.sh - cd OddityUI - git add . - git commit -m '更新通用静态包' - git push --force --quiet \"https://${PersonalAccessTokens}@${GtiHubUrlRepo}\" master:master - git tag ${GtiHubTagVersion} - git push --force --quiet \"https://${PersonalAccessTokens}@${GtiHubUrlRepo}\" ${GtiHubTagVersion}:${GtiHubTagVersion} env: global: - GtiHubTagVersion: 0.3.2 - GtiHubUrlRepo: github.com/OddityUI/OddityUI.git - CocoaPodsRepo : https://github.com/OddityUI/OddityUI","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"travis-ci","slug":"travis-ci","permalink":"http://www.msiter.com/tags/travis-ci/"},{"name":"cocoapods","slug":"cocoapods","permalink":"http://www.msiter.com/tags/cocoapods/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"奇怪的 unrecognized selector sent to instance 问题","slug":"奇怪的 unrecognized selector sent to instance 问题","date":"2017-05-18T15:39:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/05/18/奇怪的 unrecognized selector sent to instance 问题/","link":"","permalink":"http://www.msiter.com/2017/05/18/奇怪的 unrecognized selector sent to instance 问题/","excerpt":"","text":"我做了一个 黑夜模式 和 白天模式的切换。在ios8.3 的设备上发现了一个问题，会导致崩溃。控制台打出各种奇怪的问题…… unrecognized selector sent to instance 各种对象的 包括 NSURL,UIView,_FCString… 等等，我当时就蒙了，，我到底写出了什么样子的代码…… 他最终报错的地方我发送 NSnotifition的地方，也不具体跳到某一个崩溃的位置。 后来想了一下 unrecognized selector sent to instance 是由于已经销毁了，还调用。并且我的崩溃对象千奇百怪的。崩溃在发送通知的地方。那么问题大概就是出现在这里了吧。我尝试在每一个地方都进行了 dealloc移除通知的方法。果然，问题消失。其实我只移除了一个我自定义的UIView的通知，其他的UIViewControoler，没有移除也是没问题。只是为了保证百分之百…… 猜测： ios8.3的问题，在销毁后没有移除我的通知 引起各种对象的崩溃的原因，估计是因为新的对象占据了理论上销毁的对象的 物理地址","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"error","slug":"error","permalink":"http://www.msiter.com/tags/error/"},{"name":"奇怪的问题","slug":"奇怪的问题","permalink":"http://www.msiter.com/tags/奇怪的问题/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"八爪鱼 获取用户鼠标悬浮层级","slug":"八爪鱼 获取用户鼠标悬浮层级","date":"2017-05-17T14:40:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2017/05/17/八爪鱼 获取用户鼠标悬浮层级/","link":"","permalink":"http://www.msiter.com/2017/05/17/八爪鱼 获取用户鼠标悬浮层级/","excerpt":"公司一直再做新闻聚合，导致我们公司一直在爬取新闻，爬取各种软件的新闻资讯。 后来老板突发奇想，我们不如做一个八抓鱼把…… 那么找了两个同事，预言了一下。那就做吧，之后同时qt开发，紧锣密鼓的展开了。","text":"公司一直再做新闻聚合，导致我们公司一直在爬取新闻，爬取各种软件的新闻资讯。 后来老板突发奇想，我们不如做一个八抓鱼把…… 那么找了两个同事，预言了一下。那就做吧，之后同时qt开发，紧锣密鼓的展开了。 中途，我们一起聊天的时候，就说到了八抓鱼，是小白用户使用的，所以他们想爬取的内容层级，都是鼠标选中的。所以想做一个鼠标选择dom的js。跟我吐了一会苦水。那个时候不太忙，再加上那会儿我刚做完 新闻详情页的js，觉的有些经验。立马拍胸脯，我来。就有了接下来的代码。 /** * Created by Administrator on 2016/11/2. */ /* 方法说明 * @method 方法名 * @for 所属类名 * @param {参数类型} 参数名 参数说明 * @return {返回值类型} 返回值说明 */ // window.onload=function(){ // // var p = CreateShowDomXmlLabel(); // // document.body.onmousemove = function(e) { // // var dom = e.target; // // HandleSuspendViewMethod(dom); // // p.innerText = GetDomObjectAllFatherDomName(dom); // // RemoveSuspendView(); // 移除之前的显示遮挡层 // // var div = CreateSuspendView(dom); // 创建现在的遮挡层 // // document.body.insertBefore(div,p); // } // } var p = CreateShowDomXmlLabel(); document.body.onmousemove = function (e) { var dom = e.target; HandleSuspendViewMethod(dom); RemoveSuspendView(); // 移除之前的显示遮挡层 var div = CreateSuspendView(dom) document.body.insertBefore(div, p); updateLabelLocationMethod(GetDomObjectAllFatherDomName(dom), div) } /// 用户当前操作的 dom 结构体 var CurrentDomXML; /// 用户创建的遮挡层的id 名称 var SuspendViewID = \"OddityUISuspendView\"; /* * 处理用户滑动时间的开始，如果用户更换了鼠标的对象则 进行接下来的操作。否则就直接返回 * @method HandleSuspendViewMethod * @param {HTMLElment} e 用户当前滑动位置的dom结构对象 */ function HandleSuspendViewMethod(e) { if (e == CurrentDomXML) { return } CurrentDomXML = e }; /* 移除之前创建的 SuspendView * @method RemoveSuspendView */ function RemoveSuspendView() { var removeStr = document.getElementById(SuspendViewID); if (removeStr != null) { removeStr.parentNode.removeChild(removeStr); } }; //获取控件左绝对位置 function getAbsoluteLeft(o) { oLeft = o.offsetLeft while (o.offsetParent != null) { oParent = o.offsetParent oLeft += oParent.offsetLeft o = oParent } return oLeft } //获取控件上绝对位置 function getAbsoluteTop(o) { oTop = o.offsetTop; while (o.offsetParent != null) { oParent = o.offsetParent; oTop += oParent.offsetTop; o = oParent } return oTop } /* 创建遮挡层 根据 传入的 对象的 绝对定位 设置 遮挡层的 位置。以及 遮挡层的 透明度。穿透属性 * @method CreateSuspendView * @param {HTMLElment} e 用户当前滑动位置的dom结构对象 */ function CreateSuspendView(dom) { var div = document.createElement(\"div\"); div.id = SuspendViewID; /// 设置div的 黑色 和透明 div.style.opacity = 0.4; div.style.backgroundColor = \"black\"; div.style.display = \"block\"; div.style.position = \"absolute\"; div.style.borderColor = \"red\" div.style.width = dom.offsetWidth + \"px\"; div.style.height = dom.offsetHeight + \"px\"; div.style.zIndex = 99999 div.style.borderStyle = \"solid\" div.style.top = getAbsoluteTop(dom) + \"px\"; div.style.left = getAbsoluteLeft(dom) + \"px\"; /// 设置鼠标的穿透 效果 div.style.pointerEvents = \"none\"; return div } /// 创建 显示 DOM 结构的 Label function CreateShowDomXmlLabel() { var p = document.createElement(\"p\"); p.innerText = \"\"; p.style.textAlign = \"center\"; p.style.backgroundColor = \"black\"; p.style.lineHeight = \"30px\"; p.style.color = \"white\"; p.style.opacity = 1; p.style.position = \"absolute\"; p.style.height = \"30px\"; p.style.zIndex = 999991 p.style.top = \"0px\"; /// 设置鼠标的穿透 效果 p.style.pointerEvents = \"none\"; document.body.appendChild(p); return p } /// 根据传入的 dom 返回 dom 树 字符串 function GetDomObjectAllFatherDomName(dom) { var domName = \"[ - \" + dom.nodeName; while (dom.parentNode) { domName = dom.parentNode.nodeName + \" > \" + domName; dom = dom.parentNode; } return domName.toLocaleLowerCase() + \" - ]\" } function updateLabelLocationMethod(str, div) { p.innerText = str; var topLocation = div.offsetTop-40 var leftLocation = div.offsetLeft if (topLocation &lt; 10) { topLocation = div.offsetHeight + div.offsetTop + 10 } p.style.top = topLocation + \"px\"; p.style.left = leftLocation + \"px\"; return div } 测试方法，找到任意浏览器，打开开发者模式。在console控制台，复制粘贴这些代码就可以看到效果了。 其实真的是为了凑博客数的……","categories":[{"name":"Web 前端","slug":"Web-前端","permalink":"http://www.msiter.com/categories/Web-前端/"}],"tags":[{"name":"八爪鱼","slug":"八爪鱼","permalink":"http://www.msiter.com/tags/八爪鱼/"},{"name":"html","slug":"html","permalink":"http://www.msiter.com/tags/html/"},{"name":"js","slug":"js","permalink":"http://www.msiter.com/tags/js/"},{"name":"Javascript","slug":"Javascript","permalink":"http://www.msiter.com/tags/Javascript/"},{"name":"鼠标悬浮","slug":"鼠标悬浮","permalink":"http://www.msiter.com/tags/鼠标悬浮/"}],"keywords":[{"name":"Web 前端","slug":"Web-前端","permalink":"http://www.msiter.com/categories/Web-前端/"}]},{"title":"WKWebView IOS8 下 loadHtmlString错误","slug":"WKWebView IOS8 下 loadHtmlString错误","date":"2017-05-17T14:40:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/05/17/WKWebView IOS8 下 loadHtmlString错误/","link":"","permalink":"http://www.msiter.com/2017/05/17/WKWebView IOS8 下 loadHtmlString错误/","excerpt":"","text":"做项目的时候，需要展示新闻详情。经过一系列的调研，最终选定为使用 webview。因为需要支持ios7，所以我在详情页就需要同时具备 UIWebView 和 WKWebView，两种。由于IOS8才开始出现的WKWebView，所以自然而然的我当然想从ios8就是用WkwebVIew。毕竟性能好，，，各种夸但是很快就遇见一个问题，本来呢，在ios9，ios10 ，我直接调用方法就可以。 [_wkWebView loadHTMLString:htmlStr baseURL:[NSBundle oddity_shareBundle].bundleURL]; 在htmlStr 里面，我有设置的 本地图片，本地js，本地css。在 ios9-10 一切OK。但是偏偏ios8不行，加载出来本地图片，但是本地js本地css加载不出来…… 一顿谷歌，没找到…… 最终心思，那成，放弃吧…… 直接ios7-8 都是用 UIWebView吧。 找到了一些参考 但是，后来有次无聊的时候，想到了，把js和css全部放在html字符串不就好了吗？ 于是乎，有了这样子的一段代码 if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 8.0 &amp;&amp; [[[UIDevice currentDevice] systemVersion] floatValue] &lt; 9.0) { NSString *file1 = [[NSBundle oddity_shareBundle] pathForResource:@\"jquery\" ofType:@\"js\"]; NSString *file2 = [[NSBundle oddity_shareBundle] pathForResource:@\"bootstrap.min\" ofType:@\"css\"]; NSString *file3 = [[NSBundle oddity_shareBundle] pathForResource:@\"content\" ofType:@\"css\"]; if (file1 &amp;&amp; file2 &amp;&amp; file3) { NSString *fileStr1 = [NSString stringWithContentsOfFile:file1 encoding:(NSUTF8StringEncoding) error:nil]; NSString *fileStr2 = [NSString stringWithContentsOfFile:file2 encoding:(NSUTF8StringEncoding) error:nil]; NSString *fileStr3 = [NSString stringWithContentsOfFile:file3 encoding:(NSUTF8StringEncoding) error:nil]; topHeader = [NSString stringWithFormat:@\"&lt;script type=\\\"text/javascript\\\">%@&lt;/script>&lt;style type=\\\"text/css\\\">%@&lt;/style>&lt;style type=\\\"text/css\\\">%@&lt;/style>\",fileStr1,fileStr2,fileStr3]; } } 其实还可以优化的，比如这个文件其实礼物上只需要读取一次就可以的，但是我现在会每次都读取，这个时候就可以做一个缓存。或者其他云云。 我这里只是提供一个思路。。。","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"WKWebView","slug":"WKWebView","permalink":"http://www.msiter.com/tags/WKWebView/"},{"name":"Systematic distinction","slug":"Systematic-distinction","permalink":"http://www.msiter.com/tags/Systematic-distinction/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"Html 字符串转换成 AttributedString ios版本下的错误","slug":"Html 字符串转换成 AttributedString ios版本下的错误","date":"2017-05-17T14:31:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/05/17/Html 字符串转换成 AttributedString ios版本下的错误/","link":"","permalink":"http://www.msiter.com/2017/05/17/Html 字符串转换成 AttributedString ios版本下的错误/","excerpt":"在ios中想要把html字符串转换成 AttributedString ，需要使用以下方法","text":"在ios中想要把html字符串转换成 AttributedString ，需要使用以下方法 NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithData:[title dataUsingEncoding:NSUnicodeStringEncoding] options:@{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes:nil error:nil]; 这样子的话,html字符串就可以转换为 NSMutableAttributedString 对象，可以展示在可以展示 AttributedString的空间上，但是这个东西是有一定时间的耗时的。尤其是在 tableview上会消耗很大的计算时间，使滑动出现问题。那么我们就需要进行一个一步计算，并且为了更好的节省性能，我们最好做一个缓存。接下来就是我的制作方式 @interface OddityHtmlTitleCache() @property(nonatomic,strong) NSCache *sharedCache; @end @implementation OddityHtmlTitleCache // 创建一个 单利的 管理器 +(OddityHtmlTitleCache *)sharedCache{ static OddityHtmlTitleCache *sharedManager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedManager = [[OddityHtmlTitleCache alloc]init]; sharedManager.sharedCache = [[NSCache alloc] init];; }); return sharedManager; } // 根据 html字符串获取 NSAttributedString -(NSAttributedString *)htmlTitleByString:(NSString *)title{ // 在cache 提取 id viewController = [self.sharedCache objectForKey:title]; if ( viewController) { return viewController; } NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithData:[title dataUsingEncoding:NSUnicodeStringEncoding] options:@{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes:nil error:nil]; [attributedString addAttributes:@{ NSFontAttributeName:[UIFont oddity_font3], } range:[attributedString.string fullRange]]; if (attributedString) { [self.sharedCache setObject:attributedString forKey:title]; } return attributedString; } @end 最开始，我是在ios10，测试的，没有问题，但是我的同时反馈给我。他有崩溃。最终我查到了,在stackoverflow，这个转的方法，在ios9.2之前，异步执行该方法都会错误的。且行且珍惜把……","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"AttributedString","slug":"AttributedString","permalink":"http://www.msiter.com/tags/AttributedString/"},{"name":"iOS8 html2AttributedString error","slug":"iOS8-html2AttributedString-error","permalink":"http://www.msiter.com/tags/iOS8-html2AttributedString-error/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"WebKit WkwebView dealloc Crash错误","slug":"WebKit WkwebView dealloc Crash错误","date":"2017-05-17T14:19:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2017/05/17/WebKit WkwebView dealloc Crash错误/","link":"","permalink":"http://www.msiter.com/2017/05/17/WebKit WkwebView dealloc Crash错误/","excerpt":"","text":"今天遇到一个奇怪的问题，在我 dismiss UIViewController后，我的UIViewController没有销毁，这导致内存在慢慢的增长，没有销毁。查了一会儿，把问题锁定在了 WKWebView上了，我开始慢慢的注释，调试，最后发现。是我的以下代码的问题。 self.configuration = [[WKWebViewConfiguration alloc] init]; [self.configuration.userContentController addScriptMessageHandler:self name: OddityWkWebViewConfiguration]; _wkWebView = [[OddityCustomWkWebView alloc]initWithFrame:(CGRectZero) configuration:self.configuration]; 在我注释了，addScriptMessageHandler方法之后，dealloc调用了。那么就知道了问题了。在 ViewDidDisapper 方法，removeScriptMessageHandlerForName 就好了 -(void)viewDidDisappear:(BOOL)animated{ [super viewDidDisappear:animated]; [self.configuration.userContentController removeScriptMessageHandlerForName: OddityWkWebViewConfiguration]; } 再后来我发现在ios的测试机上，我推出去之后会直接崩溃。控制台打印出，野指针的问题，最后确认为野指针就是 WkWebView。后来在 stackoverflow找到了这个问题的解决。最后更新为 -(void)viewDidDisappear:(BOOL)animated{ [super viewDidDisappear:animated]; self.wkWebView.scrollView.delegate = nil; [self.configuration.userContentController removeScriptMessageHandlerForName: OddityWkWebViewConfiguration]; } 好了，不崩溃了。","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"Systematic distinction","slug":"Systematic-distinction","permalink":"http://www.msiter.com/tags/Systematic-distinction/"},{"name":"WebKit","slug":"WebKit","permalink":"http://www.msiter.com/tags/WebKit/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"Autolayout 和 size-class 简明教程","slug":"Autolayout 和 size-class 简明教程","date":"2016-11-21T03:25:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2016/11/21/Autolayout 和 size-class 简明教程/","link":"","permalink":"http://www.msiter.com/2016/11/21/Autolayout 和 size-class 简明教程/","excerpt":"教程开始前的废话连篇在iphone5出现之后，也就是ios6的时候。约束(autolayout)出现了，其实最开始的时候，ios dever们都还是坚持手写代码，毕竟自己用了好几年了，你说换就换，现在的需求你帮我写啊？所以导致当时使用约束的少之又少，直至后来出现了横屏和竖屏之类适配，而且屏幕更多繁多的时候，手写代码已经越来越不太能担任这个任务的时候，才开始慢慢的进入了这个大潮","text":"教程开始前的废话连篇在iphone5出现之后，也就是ios6的时候。约束(autolayout)出现了，其实最开始的时候，ios dever们都还是坚持手写代码，毕竟自己用了好几年了，你说换就换，现在的需求你帮我写啊？所以导致当时使用约束的少之又少，直至后来出现了横屏和竖屏之类适配，而且屏幕更多繁多的时候，手写代码已经越来越不太能担任这个任务的时候，才开始慢慢的进入了这个大潮而我比较幸运，在iphone5的时候第一次拥有了iphone手机，在我学习ios的时候，iphone6和swift这两个东西出现了。所以我最开始学习的时候就是使用 storyboard和约束一起学习的好了废话不多说了。约束到底是什么东西呢？其实说白了他是一种描述性的布局方式。什么是描述？比如说。“咳咳，这个图片距离这个按钮的右边10像素，距离屏幕上方10像素！图片的大小是80x80”。这就叫做描述，这样我们的前辈们(apple的开发人员们)，就会把我们的描述解析成相对应的布局方式，完成图片位置的放置。其实说到布局，无论手写代码还是xib,sb(storyboard)都可以进行约束的编码的。 我们教程首先学习 sb,xib这一类的布局，因为这样咱们可以很直观的看到约束对于view的布局影响。当我们足够熟悉布局的时候，再转入手写布局会方便很多这篇教程将以这几个方面进行讲解 XIB StoryBoard 约束设置 NSLayoutConstraint 约束设置 VFL 约束设置 NSLayoutAnchor 约束设置 第三方约束设置 例子总结 － 实例 总结 XIB StoryBoard 约束设置在我们学习之前，请你们自己建立一个项目。打开storyboard的预览界面，咱们在界面的最下方 下方有三个button，分别是 align pin resole auto layout issues align:英文解释的意思为排序，那么我们即可以理解为，排序…点击展开选项，我会挨个解释一下。 ps选项一共有4个类别。第一类和第二类是需要选中两个或者多个的view的时候，才可以操作 Leading Edges 选中的views们 左 对齐 Trailing Edges 选中的views们 右 对齐 Top Edges 选中的views们 上 对齐 Bottom Edges 选中的views们 下 对齐 Horizontal Centers 选中的views们 水平方向 中心对齐 Vertical Centers 选中的views们 垂直方向 中心对齐 Baselines 选中的views们基于 基线 对齐 Horizontally in Container 选中的视图 相对于 父视图 进行 水平方向 对齐 Vertical in Container 选中的视图 相对于 父视图 进行 垂直方向 对齐 Update Frames None 再设置了这些约束之后不进行Frame的更改 Update Frames Items of New Constraints 设置了这些约束之后 只更改选中的这些views的Frame Update Frames All Frames in Container 更改该 vc 里所有View的约束 (慎用!!!!!!) pin:英文解释为 大头针，其实我们就可以为，这个展开项内的所有的现象都是为了将视图订在某一个位置的。那么我们再次展开选项 上方的输入框 这个输入框时表示当前选中的views或者view距离父视图的上方距离为多少，左右下同理，不一一赘述了 而点击这个倒三角开启的选项中 User Standard Value 是说使用标准的的值，而且这个值只有在是设置上下方向的时候才有用。默认的值其实就是距离 Bottom Layout Guide，也就是上下基线。下基线就是距离视图最底部。上基线就是距离StatusView下方的位置。而这里的默认值其实是8 User Current Canvas Value 使用当前位置设置。默认为当前设置方向最近的一个VIew，且没有覆盖遮挡的视图 剩下的选项，会根据当前视图的布置情况有所不同，但是道理相当，这个选项是让你设置你要根据那个视图进行当前位置距离的设置的 Width 和 Height 这个不需要我赘述了吧。分别是 宽度和高度 的设置 Constarain to Margins. 这个是否需要外边距 默认为 8 。一般没啥卵用，都会去掉 Equal Widths 和 Equal Heights 这两个选项需要选择两个视图。比如选中View1和View2，那么可以分别设置这个两个视图宽度和高度相等 Aspect Ratio 这个属性是设置选中View的比例。当你点击设置的时候，默认他会设置当前视图的比例。比如你的View高度为40宽度为30。那么你的比例就将设置为3:4. 如果你希望修改这个比例的属性，咱们在讲完这三个东西之后，我会讲解 Align 这个东西你不得不承认这个东西和咱们学习的第一个Align重复的… 在这里就不赘述了 Update Frames 这个查看上面 Align选项的这个属性就好了 resole auto layout issues他的这个解释已经很好理解了，自动布局问题的解决。就是如果你在布局的时候出现了一些问题。比如，咱们再设置约束之后，出现黄色或者红色的的颜色的时候。就需要使用以下方式修改。红色说明咱们设置的约束有缺失或者有冲突的问题，黄色则说明，约束正确，但是当前View的Frame和约束描述的Frame不一致 看到以上视图咱们可以看出它分为两个而且这两种除了名字不一样，选项是一摸一样的额。Selected Views 这个说的就是你要处理的约束问题是当前你选中的View，而All Views in View Controller，则是说明要解决的约束问题是这个ViewController所有的VIew的(这个可得慎重的)。 Update Frames 修改Frame，当你的约束设置正确但是Frame不对的时候使用者选项可以讲View的Frame展示成为约束所描述的样子 Update Constaints 而这个选项，说实话我没用过。他的意思咱们也可以知道他是通过Frame 去修改 约束…… Add Missing Constraints 添加缺失的约束，这个选项我也没使用过，因为这个方法添加的缺失的约束不一定就是正确的约束，在实际运行中肯定会出现问题所以尽量自己把缺失的约束自己添加了。 Reset to Suggested Constaints 重新设置建议的约束？没使用过，不知道什么意思 Clear Constraints 清除约束，会删除选中的视图的所有的约束。在All Views in View Controller 你要是做这个选项的时候可得慎重，使用了就说明你要删除当前VC所有的约束。当然你可以 ctrl-z 后面的话在说了这些之后，其实咱们应该已经可以进行约束的设置了，但是还有很多问题，其中我现在说一下快速设置的问题。当你在这个层次view选择器中（图1）。 快速设置的问题。我们可以在View上按住Ctrl 键之后左键拖拽到view本身或者其他View来快速的设置一些属性，具体的属性，咱们自己看吧。他只是一种快捷方式，在属性设置上没有任何区别的，这里就不一一赘述了 快速解决约束问题的快捷键。当我们的View的约束正确的而fram没有显示正确的位置的时候我们可以使用 resole auto layout issues 进行修改，但是每次都要打开这选项实在是太麻烦了。所以我们可以选择一个快捷键。就是 osx ： comment+alt+= 而window 则为 window+alt+= 快速修改约束 设置UIScrollView的时候，因为牵扯到要设置ScrollView ContainView 的高度宽度的问题，所以再设置 ScrollView 子View 的时候一定要明确一个道理！ 就是比如保证 子视图的约束结合起来之后可以让 containView知道自己的高度和宽度，如果缺失，将导致约束失败。 修改约束的问题，咱们在修改约束的时候也是在view的选择器中。选中你要修改的VIew之后在最左侧的工具箱中（图2）。可以看到我们黄框标注出的约束。点击Edit就可以修改咱们约束的属性了 Constant 这个输入框就是约束的值，而大于等于，小于等于以及等于需要咱们根据实际情况进行自己分辨设置 Priority 优先级别，这个分别为 1000(最高)， 750(中),250(低)。三个选项，这个我没有使用过，不过估计是想两个约束发生实际运行中的冲突的时候 进行优先级显示的方法吧 Multiplier 这个就是设置比例的地方，就是咱们之前说的。而这个设置是非常好玩的一个设置，当然他也有使用的局限，在设置视图的宽度和高度的时候这个是用不了的，是设置比如 距离四周的位置？居中，或者两个视图的宽度高度相等的时候,或者比例设置的时候，才会可以设置。这个我还没有很多疑问。所以在我测试完成后，会进行修改 NSLayoutConstraint 约束设置使用NSLayoutConstraint是Apple在出约束的时候出现的，也就是官方推荐用户使用这个东西，或者sb和xib。至少当时是这样的额。但是…这个东西的费事儿成都超出你的想象 方法介绍public enum NSLayoutAttribute : Int { case left case right case top case bottom case leading case trailing case width case height case centerX case centerY case lastBaseline @available(iOS 8.0, *) case firstBaseline @available(iOS 8.0, *) case leftMargin @available(iOS 8.0, *) case rightMargin @available(iOS 8.0, *) case topMargin @available(iOS 8.0, *) case bottomMargin @available(iOS 8.0, *) case leadingMargin @available(iOS 8.0, *) case trailingMargin @available(iOS 8.0, *) case centerXWithinMargins @available(iOS 8.0, *) case centerYWithinMargins case notAnAttribute } 在网上看到一张图可以很好的说明问题。 以上的属性很多大家肯定都自己可以看懂，我也就不说了。我这里就说几个比较让人觉的不解的地方。 有 Margins 和 没有 Margins 的区别在于，咱们在SB 和 xib 中设置的 Constarain to Margins 是一个效果 Leading 在习惯从右至左看的地区，相当于NSLayoutAttributeRight; Trailing: 在习惯由左向右看的地区，相当于NSLayoutAttributeRight；在习惯从右至左看的地区，相当于NSLayoutAttributeLeft lastBaseline 文字的下基线 firstBaseline 文字的上基线 首先他的方法如下： /// 获得一个约束 /// /// - parameter view1: 第一个对象，通常就是咱们要设置的用户的View /// - parameter attr1: 你要是设置他的那个属性 查阅上方 NSLayoutAttribute 解释 /// - parameter relation: 一个Enum对象， 大于等于 小于等于 等于，自己看看吧， 不赘述了 /// - parameter view2: 第二个对象 一般是你要设置的View的SuperView。如果你只设置View的宽度或者高度这些只需要一个VIew就可以做的这个参数就为nil /// - parameter attr2: 第二个对象的 属性。 如果第二个对象为 nil。则该对象为 notAnAttribute /// - parameter multiplier: 倍数。 这里不赘述了，查看 SB xib 教程就好了 /// - parameter constant: 约束的值 /// /// - returns: NSLayoutConstraint public convenience init(item view1: Any, attribute attr1: NSLayoutAttribute, relatedBy relation: NSLayoutRelation, toItem view2: Any?, attribute attr2: NSLayoutAttribute, multiplier: CGFloat, constant c: CGFloat) 或者这样说可能更好理解一点view1.attr1 [= , &gt;= , &lt;=] view2.attr2 * multiplier + constant 在获取约束完成之后使用每个View 提供的方法 extension UIView { @available(iOS 6.0, *) open var constraints: [NSLayoutConstraint] { get } @available(iOS 6.0, *) open func addConstraint(_ constraint: NSLayoutConstraint) // This method will be deprecated in a future release and should be avoided. Instead, set NSLayoutConstraint's active property to YES. @available(iOS 6.0, *) open func addConstraints(_ constraints: [NSLayoutConstraint]) // This method will be deprecated in a future release and should be avoided. Instead use +[NSLayoutConstraint activateConstraints:]. @available(iOS 6.0, *) open func removeConstraint(_ constraint: NSLayoutConstraint) // This method will be deprecated in a future release and should be avoided. Instead set NSLayoutConstraint's active property to NO. @available(iOS 6.0, *) open func removeConstraints(_ constraints: [NSLayoutConstraint]) // This method will be deprecated in a future release and should be avoided. Instead use +[NSLayoutConstraint deactivateConstraints:]. } 这些大家根据名字就可以看懂的我就不解释了。还需要注意的一点就是，一定要设置View的 translatesAutoresizingMaskIntoConstraints 属性为false。否则会出现问题。人家说的也很明白。我要不要自己给你调整位置呢？如果你想自己调整约束来调整位置，就把我设置为false吧。默认为true VFL 约束设置终于还是到了这里了，之前学习这个的时候真是千难万难，这个东西真心的不怎么友好……废话不多说了 VFL（Visual Format Language）被称为 “可视化格式语言”，是苹果公司为了简化autolayout的编码而推出的抽象语言。 功能 写法 含义 水平方向 H: 或 V: H 说明之后的句子都是在水平方向设置约束的 V 则是垂直方向。默认方向为 H 水平方向 Views [view] 要设置的view们 SuperView &#124; view们所在的父视图 关系 &gt;=,==,&lt;= NSLayoutRelation 空间，间隙 - -30- 说明之间的空隙为30 优先级 @ 为250 750 1000 三个级别，之前咱们说过了 设置宽度高度 () [view(30)] 配合方向 水平方向就是为宽度 垂直则为高度 下面咱们来举几个例子： 代码 含义 &#124;[view]&#124; 和父视图的左右对齐 &#124;-(&gt;=100)-[view] 距父视图的左边距离大于等于100 [view] 宽度大于等于100 V:&#124;-(&gt;=100)-[view(&gt;=100)] 距父视图的上边距离大于等于100并且高度度大于等于100 约束类型public struct NSLayoutFormatOptions : OptionSet { public init(rawValue: UInt) public static var alignAllLeft: NSLayoutFormatOptions { get } public static var alignAllRight: NSLayoutFormatOptions { get } public static var alignAllTop: NSLayoutFormatOptions { get } public static var alignAllBottom: NSLayoutFormatOptions { get } public static var alignAllLeading: NSLayoutFormatOptions { get } public static var alignAllTrailing: NSLayoutFormatOptions { get } public static var alignAllCenterX: NSLayoutFormatOptions { get } public static var alignAllCenterY: NSLayoutFormatOptions { get } public static var alignAllLastBaseline: NSLayoutFormatOptions { get } @available(iOS 8.0, *) public static var alignAllFirstBaseline: NSLayoutFormatOptions { get } public static var alignmentMask: NSLayoutFormatOptions { get } /* choose only one of these three */ public static var directionLeadingToTrailing: NSLayoutFormatOptions { get } // default public static var directionLeftToRight: NSLayoutFormatOptions { get } public static var directionRightToLeft: NSLayoutFormatOptions { get } public static var directionMask: NSLayoutFormatOptions { get } } 不讲解了，我不是用这个VFL所以不会就不解释了。默认使用 ，init(0). 就好了。 方法解释/// 获得一组约束 /// /// - parameter format: vfl 格式化string /// - parameter opts: NSLayoutFormatOptions Opt /// - parameter metrics: 数据的数据 比如 [view(height)] 那么此时 metrics 就为 [\"height\":100]. 不需要则为 nil /// - parameter views: views [\"view1\":self.backView] /// /// - returns: NSLayoutConstraints open class func constraints(withVisualFormat format: String, options opts: NSLayoutFormatOptions = [], metrics: [String : Any]?, views: [String : Any]) -> [NSLayoutConstraint] 如果没有声明方向默认为水平H:（原文写的V:） 妈的，真心不能使用vfl，简直反人类。而且很多问题。比如等于父视图的宽高，剧中问题…… 等到这些问题解决了，我在用吧，现在还是尽量不使用…… 而且为了使用vfl，还得是用其他方式约束去约束他不能约束，或者我不会约束的地方，真心了累。而且他的宽高问题在横屏的时候也是一个坑。 NSLayoutAnchor 约束设置在ios9 之后，也许是受到了第三方约束框架的鼓舞，咱们的苹果公司更新了对于 autolayout的布局api。 NSLayoutAnchor 。每一个UIView都会有自己的这些属性 extension UIView { /* Constraint creation conveniences. See NSLayoutAnchor.h for details. */ @available(iOS 9.0, *) open var leadingAnchor: NSLayoutXAxisAnchor { get } @available(iOS 9.0, *) open var trailingAnchor: NSLayoutXAxisAnchor { get } @available(iOS 9.0, *) open var leftAnchor: NSLayoutXAxisAnchor { get } @available(iOS 9.0, *) open var rightAnchor: NSLayoutXAxisAnchor { get } @available(iOS 9.0, *) open var topAnchor: NSLayoutYAxisAnchor { get } @available(iOS 9.0, *) open var bottomAnchor: NSLayoutYAxisAnchor { get } @available(iOS 9.0, *) open var widthAnchor: NSLayoutDimension { get } @available(iOS 9.0, *) open var heightAnchor: NSLayoutDimension { get } @available(iOS 9.0, *) open var centerXAnchor: NSLayoutXAxisAnchor { get } @available(iOS 9.0, *) open var centerYAnchor: NSLayoutYAxisAnchor { get } @available(iOS 9.0, *) open var firstBaselineAnchor: NSLayoutYAxisAnchor { get } @available(iOS 9.0, *) open var lastBaselineAnchor: NSLayoutYAxisAnchor { get } } 大家看看这些单词就应该知道什么意思了吧。 咱们可以看到这里大概有三个类型。 NSLayoutXAxisAnchor , NSLayoutYAxisAnchor , NSLayoutDimension 分别左右边距上下边距，以及最后的 宽度和高度 而这些类型都实现 NSLayoutAnchor,他们有共同的方法 /* These methods return an inactive constraint of the form thisAnchor = otherAnchor. */ open func constraint(equalTo anchor: NSLayoutAnchor&lt;AnchorType>) -> NSLayoutConstraint open func constraint(greaterThanOrEqualTo anchor: NSLayoutAnchor&lt;AnchorType>) -> NSLayoutConstraint open func constraint(lessThanOrEqualTo anchor: NSLayoutAnchor&lt;AnchorType>) -> NSLayoutConstraint /* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant. */ open func constraint(equalTo anchor: NSLayoutAnchor&lt;AnchorType>, constant c: CGFloat) -> NSLayoutConstraint open func constraint(greaterThanOrEqualTo anchor: NSLayoutAnchor&lt;AnchorType>, constant c: CGFloat) -> NSLayoutConstraint open func constraint(lessThanOrEqualTo anchor: NSLayoutAnchor&lt;AnchorType>, constant c: CGFloat) -> NSLayoutConstraint 而 针对于高度会有比例这一个约束，所以在 NSLayoutDimension有自己的方法 /* These methods return an inactive constraint of the form thisVariable = constant. */ open func constraint(equalToConstant c: CGFloat) -> NSLayoutConstraint open func constraint(greaterThanOrEqualToConstant c: CGFloat) -> NSLayoutConstraint open func constraint(lessThanOrEqualToConstant c: CGFloat) -> NSLayoutConstraint /* These methods return an inactive constraint of the form thisAnchor = otherAnchor * multiplier. */ open func constraint(equalTo anchor: NSLayoutDimension, multiplier m: CGFloat) -> NSLayoutConstraint open func constraint(greaterThanOrEqualTo anchor: NSLayoutDimension, multiplier m: CGFloat) -> NSLayoutConstraint open func constraint(lessThanOrEqualTo anchor: NSLayoutDimension, multiplier m: CGFloat) -> NSLayoutConstraint /* These methods return an inactive constraint of the form thisAnchor = otherAnchor * multiplier + constant. */ open func constraint(equalTo anchor: NSLayoutDimension, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint open func constraint(greaterThanOrEqualTo anchor: NSLayoutDimension, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint open func constraint(lessThanOrEqualTo anchor: NSLayoutDimension, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint 大家自己看看方法就知道了，如果不知道就去文章下方例子，下载查看。 第三方约束设置 Masonry (github地址)[https://github.com/SnapKit/Masonry] SnapKit (github地址)[https://github.com/SnapKit/SnapKit] Cartography (github地址)[https://github.com/robb/Cartography] 具体的用法查看他们的教程吧，我就不献丑了。 例子总结 － 实例 那么我们来做一个个人主页的布局吧，因为这里包含的知识点比较多。而且比较好实现…… XIB StoryBoard 方式那么首先我们做一个个人主页的背景视图，让他距离上左右方为0。而高度则为整个VC的view的1/3，我录制为了动态图了。紧接着我们在个人中心的背景视图设置头像以及名字的布局约束设置一个tag分栏视图的约束设置UISCrollView的约束,以及运行效果完成滑动Progress修改约束实现 切换ViewControoller的假象这样我们就完成了 xib的 布局 总结除了第三方的约束框架，我都写了一份代码，实现同一个效果。大家有需要的可以查看github上的项目。 (Github 地址)[https://github.com/AimobierExample/AutoLayout] 这是案例的github地址，我把这个例子分为了4个分支。可以按个查看实现的约束。 写到最后才发觉其实并没有将到 size－class。有机会补上吧～","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"约束教程","slug":"约束教程","permalink":"http://www.msiter.com/tags/约束教程/"},{"name":"swift","slug":"swift","permalink":"http://www.msiter.com/tags/swift/"},{"name":"autolayout","slug":"autolayout","permalink":"http://www.msiter.com/tags/autolayout/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"制作一个自己的 Cydia 源","slug":"制作一个自己的 Cydia 源","date":"2016-11-12T02:05:43.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2016/11/12/制作一个自己的 Cydia 源/","link":"","permalink":"http://www.msiter.com/2016/11/12/制作一个自己的 Cydia 源/","excerpt":"大家肯定都知道 Cydia 吧， iPhone、iPod touch、iPad等设备上的一种破解软件，类似苹果在线软件商店iTunes Store 的软件平台的客户端，在越狱的过程中被装入到系统中的，其中多数为iPhone、iPod Touch、ipad的第三方软件和补丁，主要都是弥补系统不足用。是由Jay Freeman（Saurik）领导，Okori Group以及UCSB大学合作开发。 之前用了很多好用的源，但是很好奇的是，他们是怎么制作的呢？为什么越狱之后就可以这么厉害呢？那么怎么制作这么一个东西","text":"大家肯定都知道 Cydia 吧， iPhone、iPod touch、iPad等设备上的一种破解软件，类似苹果在线软件商店iTunes Store 的软件平台的客户端，在越狱的过程中被装入到系统中的，其中多数为iPhone、iPod Touch、ipad的第三方软件和补丁，主要都是弥补系统不足用。是由Jay Freeman（Saurik）领导，Okori Group以及UCSB大学合作开发。 之前用了很多好用的源，但是很好奇的是，他们是怎么制作的呢？为什么越狱之后就可以这么厉害呢？那么怎么制作这么一个东西 制作自己的 Cydia源Cydia 说白了启示就是一个云盘，你们需要的呢，只是需要几个文件，来告诉过来访问这个云盘的Cydia程序，我这个源叫啥？谁制作的这个源？这个源里都有什么软件？这些源的放置位置都是啥？那么如何制作自己的云盘呢？ 几种办法 第一种就是自己做一个服务器，本地跑起来。 github 任何一个直接访问的文件存储地方 比如 七牛云。 Cydia 源的文件结构 +- / +- Release +- Packages +- CydiaIcon.png +- debs +- *.deb 文件讲解/ 服务器根目录/Release 文件记录软件源本身的相关信息 ，例如作者 之类的/Packages 记录具体软件包的存放位置和安装信息等数据/CydiaIcon.png ICON 显示的ICON图片/debs 存放所有deb包的目录/debs/*.deb deb包…… Release 文件讲解必须Origin: 软件源名称，可以使用中文（Cydia的软件源列表中显示的标题）Label: 同上，也可以使用中文Suite: 软件源的类型，比如正式源，测试源等，可以分别用stable, beta, unstable等来表示，一般填stable就可以了Version: 版本号，这个其实不重要，随便填，一般都是写1.0Codename: 代码代号，比如BigBoss的就写BigBoss，威锋的就写WeiPhone，也没什么限制，只能用英文Architectures: 结构。iPhone平台统一写iphoneos-armComponents: mainDescription: 软件介绍，可以使用中文和html代码，具体能使用哪些代码在下面会介绍。 可选Support: 支持，没什么作用，除非特别需要，否则可以不要这个。MD5Sum: 不是必须的，但如果Packages文件位置不与Release文件在同一目录下，则必须有此项。另外，如果需要签名Release文件，也必须有这个。关于MD5Sum的格式，在下文也会介绍。 Description格式 显示在Cydia中每个软件页面最下方。 不能直接换行，如果要实现显示换行显示，可以使用代码。 要加粗显示，可以使用代码 可以使用html代码设置字体颜色。 不能使用超链接代码。 代码： Description: WeiPhone-威锋网为您提供iPhone所需软件/补丁。&lt;br&gt;联系我们: &lt;strong&gt;weip.com@ gmail.com&lt;/strong&gt;; 生成Packages文件 将 deb 文件放在一个文件夹下，比如说debs下 命令行里进入到debs目录的上级目录 Packages存放于当前目录 执行命令 dpkg-scanpackages debs &gt; Packages 执行命令 bzip2 -zfk Packages 生成 Packages.bz2 执行命令 gzip -fk Packages 生成 Packages.gz ps 4.5.6 可以使用 dpkg-scanpackages debs &gt; Packages &amp;&amp; bzip2 -zfk Packages &amp;&amp; gzip -fk Packages 这样会自动将debs文件夹下的所有 deb文件信息 打印至 Packages 文件里 (旧) 制作 自己deb 文件总结 先把文件夹结构弄好 在 Applications 文件夹下面放入自己的 .app 文件 在 DEBIAN 文件夹下面放入 control描述文件，以及根据自己的需求放入脚本文件 使用 chmod -R 0755 Directory 设置权限 使用 dpkg-deb -b Directory a.deb 命令打包 使用 dpkg-name a.deb 规范命名 各个文件讲解先生成如下的文件目录结构： +- Directory +- Applications | +- Example.app | | +- Info.plist | | +- Example | | +- icon.png +- DEBIAN +- control +- preinst/postinst/prerm/postrm/extrainst_ /Directory : 任意的一个文件夹放置主要的文件/Directory/Applications : 放置.app文件夹/Directory/Applications/Example.app : .app文件夹 /DEBIAN : 放置描述的文件/DEBIAN/control : 记录了软件包标识，软件名，介绍，作者，冲突软件等信息，用来标识一个软件包 DEBIAN/control 文件描述以下为必须项 Package : 软件包标识符，类似于*，一个软件包必须要有一个唯一的标识符。通常是用com.xxx.abc这样的形式来命名。Architecture: 架构，用于标识运行的系统，iPhone上为iphoneos-armVersion: 版本号，不能用下划线和逗号和空格。格式有（以逗号分隔） 1.0，1.0f，0-1，1:1.0，其中1:1.0这种格式比较特殊，在Cydia中，1:1.0仍然会显示为1.0，但版本号实际是高于1.0的。 以下为可选项Name: 软件包在Cydia中的显示名称，中英文不限，也可以用空格，但不宜过长（长了显示不完全）。Author: 软件作者。Maintainer: 维护者，一般是软件源的拥有者。Sponsor: 负责人，可以是个人也可以是网站。 Author，Maintainer，Sponsor 的格式相同，均为 名称+空格+&lt;邮件地址或网址&gt;，经测试，如果名称为中文的话，即使写了邮件地址和网址，在Cydia中点击也不会跳转。 示例： WEIP.Tech &#119;&#101;&#105;&#112;&#46;&#x63;&#x6f;&#109;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#44;&#x63;&#x6f;&#x6d; 或 WeiPhone.com http://www.weiphone.com 如果没有邮件地址或网址，则不需要 &lt;&gt; 及&lt;&gt;中的内容。中文名或未提供邮件/网址，无 &gt; 符号 Icon: 指定软件包的图标显示。当无Icon设定时，Cydia会显示该软件包所在的分类的图标。 格式： 在线地址，如 http://www.abc.com/abc.png 本地地址：file://+路径，如file:///Applications/Cydia.app/Sources/app.weiphone.com.png注：在软件页面（非列表页面），自定义的图标是不会显示的，显示的是分类图标。 Section: 软件分类，中英文无限制，排列顺序是 英文-&gt;中文。Installed-Size: 解包后的文件大小，可以有小数位，以kb为单位，不需要注明kb，这个不需要很精确，而且小数位在Cydia里显示不出来（不是四舍五入，全部舍了）。至于文件大小是否包含DEBIAN目录中的内容就随意了。Priority: 优先级，可填 Required，Important，Standard，Optional，Extra，依次为 必须，重要，一般，可选，次要。虽然没有什么实际作用，但优先级为Required和Important的软件包在卸载时会有警告，这样可以避免删除一些系统必须的软件。但Required和Important不要滥用，一般用Standard，Optional或Extra即可。优先级在Cydia中是不会显示的Essential: 是否必须软件包，可填 yes 和 no， 填yes则为必须软件包，卸载时Cydia会有警告。卸载Essential标记为yes的软件包可能会导致系统问题。当然此功能需慎用，不要因为不希望用户删除自己的软件而加入Essential: yes。如果没有Essential这项的话默认就是非必须的，相当于Essential: no。Depends: Depends 字段应该包含您的软件包正常工作绝对必需的任何软件包的名称。Pre-Depends: “Pre-Depends”是为特例而保留的。当某个软件包被作为”Pre-Depends”列出时，它强制系统在试图安装您的软件包之前完全安装所指定的软件包。Conflicts: 冲突软件包。比如软件包A和B有冲突，不能同时安装。比如说A和B冲突，当系统已经安装了A的时候尝试安装B，则不能继续。Provides: 提供的软件包，比如说软件包A包含B的全部功能，那么则是A provides B，因此可以在安装了A的前提下不安装B。但此功能在非Cydia的软件管理工具中可能会无法识别（实际是这些软件不合deb标准）Replaces: 替换软件包，安装A会替换B。 以上5项的格式相同，直接填软件包的Package标识即可，如果需要加入版本号，则为 软件表标识+空格+(判断符号 版本号).比如 Depends: apt-key, firmware (&gt;=3.0)， 这表示依赖于apt-key，不限版本，firmware，且版本大于或等于3.0。 判断符号：远远低于（&lt;&lt;）、低于(&lt;)、低于或等于（&lt;=）、仅等于（=）、等于或高于（&gt;=）、大于（&gt;）以及远远高于（&gt;&gt;）。 表示多个软件包，以英文逗号分隔。 表示“或”关系，用 | 分隔。比如软件包C依赖于A或B，可写Depends: A | B。 但“或”关系要慎用。原因是，当不存在“或”关系的时候，假设B依赖于A，且系统并未安装A，那么在Cydia中安装B的时候会自动下载安装A。而假如说C依赖于A或B，且A与B都未安装，那么在安装C的时候就会失败，因为系统无法判断是应该下载A还是B。除非系统已经安装了A或B，否则C不能安装。 一个特殊的依赖：firmware。这个Package记录了固件版本，在对固件版本有要求的软件包上特别重要。 假设B依赖于A，那么在卸载A的时候也会一起卸载B Description: 软件描述，不能在control里直接换行，如果需要实现换行显示，可以使用代码。当指定了Depiction时，在软件查看页面不会显示Description。Depiction: 功能类似于软件描述，链接到一个网页，以网页的内容代替软件描述。只在软件查看页面显示，在软件包列表页面不显示。 可以使用本地网页，格式同Icon。 注意：此功能可能会消耗大量网络流量。Homepage: 链接到页面，Cydia中显示为More Information。 页面不会主动加载。Tag: 可选项有 commercial, console, daemon, extension, library, uikit, x，对应图标文件在 /Applications/Cydia.app/Purposes 目录下。也可以自行添加 purpose 分类，并加入同名图标即可。 role:: 软件包使用者归类。developer开发者，hacker骇客，enduser普通用户，该标签用于Cydia中软件包显示过滤。 cydia::commercial Cydia Store软件。 例子如下: Package: com.weiphone.source Name: WeiPhone威锋中文源 Version: 1.0 Essential: no Icon: file:///Applications/Cydia.app/Sources/app.weiphone.com.png Installed-Size: 133.7 Replaces: con.weiphone.logo Conflicts: con.weiphone.logo Provides: con.weiphone.logo Depends: cydia Priority: Standard Maintainer: WEIP.Tech Author: WEIP.Tech Section: Repositories Architecture: iphoneos-arm Description: WeiPhone Chinese Repository威锋中文源 HomePage: http://www.weiphone.com/ Sponsor: WeiPhone.com Tag: purpose::repository, role::enduser DEBIAN/preinst/postinst/prerm/postrm/extrainst_ 文件描述很多时候deb安装并不是把文件复制到iPhone里就可以了，还需要执行一些命令，比如设置权限，备份文件，加载启动进程等等，那么这时候就需要一些脚本来实现这些操作。 标准的deb脚本有4个preinst,postinst,prerm和 postrmpre是表示XX之前的前缀，post是表示XX之后的前缀，inst是install（安装）的缩写，rm是remove（移除）的缩写，所以这4个脚本的功能很明显： preinst: 在复制文件前执行的脚本 postinst: 在复制文件之后执行的脚本 prerm: 在卸载前执行的脚本 postrm: 在卸载之后执行的脚本 在Cydia中还存在一个独立的脚本,extrainst_,从字面上来讲就是额外的安装脚本。这个脚本是Cydia的作者Saurik为解决某些脚本只需要在安装时执行，在升级时不执行而专门引入的一个脚本，功能跟postinst差不多，和Installer时代的“ahhhh”比较相似。关于extrainst_的详情可以看看这个：http://www.telesphoreo.org/piper … ptember/000252.html 5个脚本的编写方法基本是一样的，但为了适应Cydia的安装，在某些情况下需要进行特定的配置。 查看某些deb可能会发现这样的语句： if [[ $1 == install || $1 == upgrade ]]; then 这种语句是为了区别安装/升级/卸载而准备的脚本。$1是一个外部变量，将这个外部变量传入脚本来执行，而这个外部变量是由Cydia软件自身生成的。 简单来说，如果是安装，则是 $1 == install ；如果是升级，则是$1 == upgrade；如果是卸载则是 $1 == remove。 if 是个判断语句，当满足if后[ ]中的指定条件时，if中的内容就会执行。那么这里就可以通过设定install/upgrade/remove来控制在不同操作时执行的命令。 但要注意的是，这个功能只能在Cydia中使用，其它的apt软件管理工具，如Icy，Rock等，不能识别这个命令，因此无法执行if中的语句，所以在写脚本的时候到底需不需要用这种格式，就看自己的需要了。 总体来说，Unix的脚本（Shell Script）有其固定的格式。 文件顶头为 #!/bin/bash 表示调用bash这个shell 之后就是运行的命令了。 脚本中如果需要注释，可以使用 # 符号。 以 # 开头的行会被当作注释，里面的内容在执行过程中没有意义。 通配符： * 最常用的两个命令自然是设置属性/权限/用户/组 设置属性/ 会使用到的系统命令操作权限chmod 【-R】 属性 文件名 由于deb的脚本执行都是在root用户下，因此不需要提升权限，即不需要使用sudo命令。 -R参数：表示递归，加上此参数会将指定的目录及其子目录的全部目录和文件的属性改变。 属性：有多种写法。具体可以看 http://baike.baidu.com/view/1229012.htm?fr=ala0_1 比较常用的几种属性： chmod +x XXXXX 为文件增加可执行权限 chmod 0644 XXXXX 不可执行文件最常使用的权限 chmod 0755 XXXXX 可执行文件最常使用的权限 实例： chmod -R 0755 /Applications/Cydia.app 设置用户/组chown 【-R】 用户:组 文件名 同样不需要sudo来提示权限。-R也是表示递归。 比如要将文件A设为root用户，wheel组，可以使用命令 chown -R mobile:mobile /var/mobile/Documents 复制文件/文件夹cp 【参数】 原始文件 目的文件 参数列表： -l（小写字母L）：创建硬链接，相当于一个镜像，而不是实际创建两个文件cp -l abc def -f：强行复制，如果目的文件已存在，覆盖之且不提示cp -f abc def -p：保留文件的属性、用户、组、时间戳等信息 cp -p abc def -r和-R：作用都是递归，将文件夹下的全部子文件和子文件夹一起复制 cp -r abc/ def/ -s：创建符号链接而不是创建双份文件 cp -s abc/ def/ -n：如果目的文件已存在，则不覆盖且不提示 cp -n abc def -a：相当与-dR，保留文件自身的属性等数据，一并复制子文件/文件夹 cp -a abc/ def/ 移动文件/文件夹 &amp; 重命名mv 【参数】 源文件 目的文件 -f：强行移动，如果目的文件已存在，覆盖之且不提示 其实 mv 命令就是复制之后再删除，但 mv 命令会自动保留文件的属性等数据，移动文件夹时会自动移动子文件/子文件夹，因此都不需要另外的参数。 重命名是由mv命令来实现的，mv 就是将 源文件 移动到 目标文件的位置并以目标文件的文件名保存。 显示语句echo &quot;Some Thing&quot;; 示例：显示语句 “测试echo命令”。 echo &quot;测试echo命令&quot;; 管理自启动服务launchctl load或unload -w plist文件路径 实例： 让wefit3自启动 launchctl load -w /System/Library/LaunchDaemons/com.weiphone.fitx.plist 禁用iPhone日志记录syslogd launchctl unload -w /System/Library/LaunchDaemons/com.apple.syslogd.plist PS: 记录自启动进程的plist文件保存在以下两个目录： /System/Library/LaunchDaemons/ 和 /Library/LaunchDaemons/ 杀死进程killall 进程名 示例：关闭Safari进程 killall safari 判断基本格式是 if [ 判断条件一 ]; then 执行命令 else 执行命令 fi 实例： 如果文件abc存在，则备份为abc.bak，否则将文件def重命名为abc if [ -f abc]; then mv -f abc abc.bak else mv def abc fi 其中[ -f abc ]可以由[ -e abc]取代 如果目录abc不存在，则新建一个目录abc if [ ! -e abc ]; then mkdir abc fi 获取固件系统版本号sw_vers -productVersion 获取设备型号uname -i uname -m Cydia中安装完之后重新启动SpringBoarddeclare -a cydia cydia=($CYDIA) if [[ ${CYDIA+@} ]]; then eval &amp;quot;echo &amp;#39;finish:reboot&amp;#39; &amp;gt;&amp;amp;${cydia[0]}&amp;quot; fi 几个比较有用的实例 备份 preinst（安装之前就要把原始文件备份，不能等到安装完已经覆盖以后才备份） if [ ! -f 原始文件备份 ]; then echo &amp;quot;原始文件的备份已存在，跳过备份&amp;quot; else cp -p 原始文件 原始文件备份 echo &amp;quot;原始文件已备份&amp;quot; fi postrm（还原备份） echo &quot;还原备份&quot;; mv -f 原始文件备份 原始文件 备份操作在制作补丁的时候，尤其是替换类型的补丁时特别有用 判别具体固件版本 在control里可以通过Depends来设置依赖的固件版本，但有时候需要在某个特定固件版本下进行操作 比如说一个软件，要求固件版本大于或等于3.0，但在固件版本为3.1的时候必须删除某一个文件才能运行，那么脚本可以这样写： firmware=$(sw_vers -productVersion) if [[ $firmware == 3.1 ]]; then 删除文件 fi 判别设备型号 当设备型号为iPod Touch时删除某个文件platform=$(uname -i) if [[ $platform == &amp;quot;N45AP&amp;quot; || $platform == &amp;quot;N72AP&amp;quot; || $platform == &amp;quot;N18AP&amp;quot; ]]; then 删除文件 fi 或platform=$(uname -m) if [ $platform == iPod* ]; then 删除文件 fi 更多关于Shell Script的信息请见 http://www.hack base.com/tech/2009-10-10/56808.html 打包如果在DEBIAN中有脚本存在，则需要将整个DEBIAN文件夹及子文件属性设为0755,如果没有脚本的话保留0644属性即可，0755属性也没问题。 chmod -R 0755 DEBIAN 打包命令 dpkg-deb -b PATH FILENAME 其中PATH是打包deb的工作目录，DEBIAN文件夹需位于PATH指定的目录下 FILENAME是deb的文件名，这个可以自己决定。 以上命令打包deb默认是采用gz格式压缩，压缩率有限，如果要获得更改的压缩率（更小的文件体积），可以使用bzip2和lzma格式。 压缩为bzip2格式 dpkg-deb -bZ bzip2 PATH FILENAME 压缩为bzip2格式 dpkg-deb -bZ lzma PATH FILENAME 默认的gz格式压缩率最低，bzip2格式居中，lzma格式压缩率最高。（当然也会有例外） PS: 压缩率越高，压缩时间越长，在iPhone上使用较高的压缩率有更大概率导致失去响应。 iPhone OS 2.x无lzma组件，因此无法安装lzma压缩的deb。iPhone OS 3.x可以解压lzma压缩。 如果deb包含的文件文本量比较大，那么一般可以获得不错的压缩率。但如果是像铃声，jpg/png图片这样文件本身就是压缩格式的情况，继续压缩的可能性就不高了，这类情况很难获得比较好的压缩率 【可选】deb文件规范命名dpkg-name abc_1.0.deb 如果想指定文件名格式，可以使用 dpkg-name --help 图形界面的deb制作工具 Debian Package Maker 网址： http://code.google.com/p/debianpackagemaker/ 个人感觉不如直接在命令行里来的直观，有兴趣的朋友可以自己试试。 ［ 需要翻墙 ］ (新) 制作自己的deb文件安装theos安装方法 选择theos的安装目录，官方建议放在默认的 /opt/theos.然后执行 export THEOS=/opt/theos 为了验证设置成功没有 echo $THEOS 如果打印 /opt/theos 说明摄制完成 Using git: git clone --recursive git://github.com/DHowett/theos.git /opt/theos Alternatively, you can use svn, if you prefer: svn co http://svn.howett.net/svn/theos/trunk $THEOS git clone -b stableversion https://github.com/haorenqq/theos/ $THEOS不要执行上面的语句，用上面的方法替换 特别感谢网名为逍遥笛子 的热心朋友 提供的分支，由于原theos最新的版本不兼容iosopendev，所以用15年的老版本 以上操作，如果出现任何关于权限的错误。使用sudo就可以了。 安装idld其实我不知道这个是干什么的？但是呢，说是签名的。。。但是我没用到过，但是还是记录一下毕竟有不少坑 按照官方的教程是如此的说的。 git clone git://git.saurik.com/ldid.git cd ldid git submodule update --init ./make.sh cp -f ./ldid $THEOS/bin/ldid 但是通常发生错误，第一个错误就是 引入了 #include &lt;openssl/err.h&gt; ，默认是不存在 这个文件夹的额。第二个错误就是 make.sh中的代码默认是只匹配Xcode5-1-1的名称，所以需要修改 make 文件。 下载 文件 修复 接下来使用命令。生成 ldid 文件./make.sh . 反正我是生成失败了 你可以直接下载别人已经编译完成的文件 ldid文件 之后将文件拷贝到 /opt/theos/bin 下就可以了 安装iOSOpenDevgit clone https://github.com/AimobierExample/iOSOpenDevInstallFix cd iOSOpenDevInstallFix sh repair.sh 之后打开 iOSOpenDev-1.6-2.pkg 按照提示就可以安装完成了 打开xcode就可以看见越狱的项目了 选择 Logos TWeak 按照xm文件内的提示，libsubstrate.dylib添加到工程中(在安装好的/opt/iOSOpenDev/lib 目录下)，然后把xm中的内容清空。mm文件的内容会根据xm文件中的内容编译后自动生成。 %hook SpringBoard - (void)applicationDidFinishLaunching:(id)application{ %orig; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:@&quot;HelloWorld!&quot; delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil]; [alert show]; } %end 点击菜单 Product - Build For - Profiling 这个时候通常会报错，因为真机调试会出现问题 Failed to create directory /var/root/iOSOpenDevPackages on device 你的iOS设备IP地址 但是此刻已经在项目根目录下出现了 变已完成的 deb文件了，你可以直接添加到咱们的源服务器中，按照之前的教程生成 packages 完成安装。 真机调试现在调试越狱设备，在已经越狱的手机上打开Cydia，搜索下列插件如果搜索不到，打开软件源-编辑 删除BigBos和ModMyi，再回到首页，点击更多软件源，重新添加这两个即可搜索到下列插件 Core Utilities Core Utilities(/bin) diskdev-cmds file-cmds system-cmds Mobileterminal openSSH sshpass toggle ssh preferencdloader substrate safe mode syslogd to /var/log/syslog 再在Xcode中的Target的Build Settings中的Code Signing中，改为Don’t Code Sign.最后打开Target-Build Settings 找到iOSOpenDevDevice选项，填入越狱手机的本地ip 之后打开终端创建key iosod sshkey -h 192.168.23.71（换成你的iOS设备IP地址） 创建完成 点击菜单 Product - Build For - Profiling 就可以安装到设备，安装完成之后，设备回自己重启，之后就会弹出了一个alertView。 Theos 创建 Cydia 应用首先安装 Theos安装方法 选择theos的安装目录，官方建议放在默认的 /opt/theos.然后执行 export THEOS=/opt/theos 为了验证设置成功没有 echo $THEOS 如果打印 /opt/theos 说明摄制完成 Using git: git clone --recursive git://github.com/DHowett/theos.git /opt/theos 使用Theos创建应用安装完成之后 使用： /opt/theos/bin/nic.pl 调用之后 msiter:~ jingwenzheng$ /opt/theos/bin/nic.pl NIC 2.0 - New Instance Creator ------------------------------ [1.] iphone/activator_event [2.] iphone/application_modern [3.] iphone/cydget [4.] iphone/flipswitch_switch [5.] iphone/framework [6.] iphone/ios7_notification_center_widget [7.] iphone/library [8.] iphone/notification_center_widget [9.] iphone/preference_bundle_modern [10.] iphone/tool [11.] iphone/tweak [12.] iphone/xpc_service Choose a Template (required): 2 Project Name (required): Demo Package Name [com.yourcompany.demo]: com.demo Author/Maintainer Name [荆文征]: jwz [iphone/application_modern] Class name prefix (two or more characters) [XX]: demo Instantiating iphone/application_modern in demo/... Done. msiter:~ jingwenzheng$ 这样就创建完成了 运行到真机首先要确保震级上面安装 openssh ssh root@ip地址 密码。默认为 alpine 这样连接上就说明安装完成，可以调用的到～ 之后设置环境变量THEOS_DEVICE_IP 为 真机 IP。 之后 cd 目录。 使用命令安装到真机上 make package install 第一个问题 ldid你可以直接下载别人已经编译完成的文件 ldid文件 之后将文件拷贝到 /opt/theos/bin 下就可以了 默认是没有权限的 所以可能需要 sudo. 复制完成之后赋予权限sudo chmod 777 /opt/theos/bin/ldid 第二个问题 dpkg没有安装文件工具 brew install dpkg dpkg 1.18.14 版本问题在 1.18.14 版本，dpkg lzma 不能使用了，必须使用 xz 这个时候需要修改 /opt/theos/makefiles/package/deb.mk 文件ifeq ($(_THEOS_PACKAGE_FORMAT_LOADED),) _THEOS_PACKAGE_FORMAT_LOADED := 1 _THEOS_DEB_PACKAGE_CONTROL_PATH := $(or $(wildcard $(THEOS_PROJECT_DIR)/control),$(wildcard $(THEOS_PROJECT_DIR)/layout/DEBIAN/control)) _THEOS_DEB_CAN_PACKAGE := $(if $(_THEOS_DEB_PACKAGE_CONTROL_PATH),$(_THEOS_TRUE),$(_THEOS_FALSE)) _THEOS_DEB_HAS_DPKG_DEB := $(call __executable,dpkg-deb) ifneq ($(_THEOS_DEB_HAS_DPKG_DEB),$(_THEOS_TRUE)) internal-package-check:: @echo \"$(MAKE) package requires dpkg-deb.\"; exit 1 endif ifeq ($(_THEOS_DEB_CAN_PACKAGE),$(_THEOS_TRUE)) # Control file found (or layout/ found.) THEOS_PACKAGE_NAME := $(shell grep -i \"^Package:\" \"$(_THEOS_DEB_PACKAGE_CONTROL_PATH)\" | cut -d' ' -f2-) THEOS_PACKAGE_ARCH := $(shell grep -i \"^Architecture:\" \"$(_THEOS_DEB_PACKAGE_CONTROL_PATH)\" | cut -d' ' -f2-) THEOS_PACKAGE_BASE_VERSION := $(shell grep -i \"^Version:\" \"$(_THEOS_DEB_PACKAGE_CONTROL_PATH)\" | cut -d' ' -f2-) $(_THEOS_ESCAPED_STAGING_DIR)/DEBIAN: $(ECHO_NOTHING)mkdir -p \"$(THEOS_STAGING_DIR)/DEBIAN\"$(ECHO_END) ifeq ($(_THEOS_HAS_STAGING_LAYOUT),1) # If we have a layout/ directory, copy layout/DEBIAN to the staging directory. $(ECHO_NOTHING)[ -d \"$(THEOS_PROJECT_DIR)/layout/DEBIAN\" ] && rsync -a \"$(THEOS_PROJECT_DIR)/layout/DEBIAN/\" \"$(THEOS_STAGING_DIR)/DEBIAN\" $(_THEOS_RSYNC_EXCLUDE_COMMANDLINE) || true$(ECHO_END) endif # _THEOS_HAS_STAGING_LAYOUT $(_THEOS_ESCAPED_STAGING_DIR)/DEBIAN/control: $(_THEOS_ESCAPED_STAGING_DIR)/DEBIAN $(ECHO_NOTHING)sed -e '/^[Vv]ersion:/d' \"$(_THEOS_DEB_PACKAGE_CONTROL_PATH)\" > \"$@\"$(ECHO_END) $(ECHO_NOTHING)echo \"Version: $(_THEOS_INTERNAL_PACKAGE_VERSION)\" >> \"$@\"$(ECHO_END) $(ECHO_NOTHING)echo \"Installed-Size: $(shell du $(_THEOS_PLATFORM_DU_EXCLUDE) DEBIAN -ks \"$(THEOS_STAGING_DIR)\" | cut -f 1)\" >> \"$@\"$(ECHO_END) before-package:: $(_THEOS_ESCAPED_STAGING_DIR)/DEBIAN/control _THEOS_DEB_PACKAGE_FILENAME = $(THEOS_PACKAGE_DIR)/$(THEOS_PACKAGE_NAME)_$(_THEOS_INTERNAL_PACKAGE_VERSION)_$(THEOS_PACKAGE_ARCH).deb internal-package:: $(ECHO_NOTHING)COPYFILE_DISABLE=1 $(FAKEROOT) -r dpkg-deb -Zgzip -b \"$(THEOS_STAGING_DIR)\" \"$(_THEOS_DEB_PACKAGE_FILENAME)\" $(STDERR_NULL_REDIRECT)$(ECHO_END) # This variable is used in package.mk after-package:: __THEOS_LAST_PACKAGE_FILENAME = $(_THEOS_DEB_PACKAGE_FILENAME) else # _THEOS_DEB_CAN_PACKAGE == 0 internal-package:: @echo \"$(MAKE) package requires you to have a layout/ directory in the project root, containing the basic package structure, or a control file in the project root describing the package.\"; exit 1 endif # _THEOS_DEB_CAN_PACKAGE endif # _THEOS_PACKAGE_FORMAT_LOADED 这样按理就可以运行了","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"越狱","slug":"越狱","permalink":"http://www.msiter.com/tags/越狱/"},{"name":"cydia","slug":"cydia","permalink":"http://www.msiter.com/tags/cydia/"},{"name":"制作源","slug":"制作源","permalink":"http://www.msiter.com/tags/制作源/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"WKWebView 制作详情页的一些经验","slug":"WKWebView 制作详情页的一些经验","date":"2016-09-21T03:25:00.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2016/09/21/WKWebView 制作详情页的一些经验/","link":"","permalink":"http://www.msiter.com/2016/09/21/WKWebView 制作详情页的一些经验/","excerpt":"Hello World好久好久没有更新过博客了，今天去面试了一家公司。被询问到关于资讯类App的详情页问题，想到了很多之前做详情页时候遇见的问题和解决的问题，所以心血来潮的想记录下来。","text":"Hello World好久好久没有更新过博客了，今天去面试了一家公司。被询问到关于资讯类App的详情页问题，想到了很多之前做详情页时候遇见的问题和解决的问题，所以心血来潮的想记录下来。 如何去展示一个详情页呢那么废话少说，亮剑吧！ 如何去显示一个WKWebView呢其实怎么说呢，我觉的其实吧。每个人都大同小异。无非就是如何将数据转换成Html并且将字符串传递给WebView。之后展示出来而已。那么我们很快就会遇到第一个问题。如何将数据转换成Html格式的字符串呢？ 搞定我们的模板君我不清楚其他开发者们遇见的数据结构，但是我的数据结构如下/ // // NewContent.swift // Journalism // // Created by Mister on 16/5/30. // Copyright © 2016年 aimobier. All rights reserved. // import RealmSwift /// 频道的数据模型 open class Content: Object { /// 用于获取评论的 docid dynamic var txt: String? = nil /// 新闻Url dynamic var img: String? = nil /// 新闻标题 dynamic var vid: String? = nil } /// 频道的数据模型 open class NewContent: Object { /// 新闻ID dynamic var nid = 1 // 新闻的详情 let content = List&lt;Content>() // Should be declared with `let` // More …… } 详情页对象包含三个字段 img,txt,vid。也就是图片，文字，视频三种类型。那这样就简单了。把他们拼装成一个Html 还不简单~ String += String // ????? 这样子？ 我是拒绝的…… 之后想起来之前做服务的时候 jsq，ejs… 这些视图模板都是可以完成现在的需求的，不知道IOS 有没有呢？ 所以说！ 废话！ 当然有啊！ MGTemplateEngine 这就是了~ 但是！！！ 问题这个大神没有使用那个第三方的管理插件来让别人导入自己的框架~ 难道我又要回归到 之前那段 被拖拽引入所支配的恐惧吗？ ???? 我还是拒绝的~~~ 那么接下来就有两种方式来引入这个框架了~ 当然了 全都是 Cocoapods的…… 第一种使用 本地引入的方式： 如果你想本地引入的话，那很简单的 在你的项目根目录下建立一个文件夹 取名字呢~ 就叫做 MGTemplateEngine ，之后 把 clone 下来的 MGTemplateEngine 项目放入一个新建的Classes 目录下。之后再classes 同级目录中新建一个 文件 MGTemplateEngine.podspec 里面的代码呢，大概写成这样子 # # Be sure to run `pod lib lint SwaggerClient.podspec' to ensure this is a # valid spec and remove all comments before submitting the spec. # # Any lines starting with a # are optional, but encouraged # # To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html # Pod::Spec.new do |s| s.name = \"MGTemplateEngine\" s.version = \"1.0.0\" s.summary = \"奇点资讯\" s.description = &lt;&lt;-DESC if you～ Shabi Boom Sha Ga la ga DESC s.platform = :ios, '7.0' s.requires_arc = true s.framework = 'SystemConfiguration' s.homepage = \"https://github.com/swagger-api/swagger-codegen\" s.license = \"MIT\" s.source = { :git => \"https://github.com/swagger-api/swagger-codegen.git\", :tag => \"#{s.version}\" } s.author = { \"Swagger\" => \"apiteam@swagger.io\" } s.source_files = 'Classes/**/*' s.public_header_files = 'Classes/**/*.h' end 所有说大概的目录分布呢~ 是这个样子的~ ── 项目根目录 ├ MGTemplateEngine ├──────├ MGTemplateEngine.podspec ├──────├ Classes │ └──── MGTemplateEngine 所有的文件 └ 你的其他文件 之后呢，在你项目中的Podfile 写下这样的代码~ pod 'MGTemplateEngine', :path => 'MGTemplateEngine/' ## MGTemplateEngine组件 运行完成 pod install~ Woooooo~ 搞定~ 第二种呢 pod 'JMGTemplateEngine' 这个东西是我自己做的为了方便……………… 运行完成 pod install~ Woooooo~ 搞定~ 显示出来我们的详情吧~没什么好说的直接上代码吧 import MGTemplateEngine extension MGTemplateEngine{ static var shareTemplateEngine:MGTemplateEngine!{ let templateEngine = MGTemplateEngine() templateEngine.matcher = ICUTemplateMatcher(templateEngine: templateEngine) return templateEngine } } func getHtmlResourcesString() -> String{ let variables = [\"title\":self.title,\"source\":self.pname,\"ptime\":self.ptime,\"theme\":\"normal\",\"body\":body] let result = MGTemplateEngine.shareTemplateEngine.processTemplateInFile(atPath: templatePath, withVariables: variables) return result! } 这样子我们就得到了Html 的String 对象，在这个时候，我们只要 使用WkWebView的 loadHTMLString 方法就OK了啊～ 是的我们很快的就发现了～ 我们真的可以展示了～ 但是，行高怎么办呢？ 那我们很快就遇到了我们的几个坎 遇到的坎坷虽然展示完成了，但是接下来我们就遇到了几个问题。 接下来针对这几个问题，我来给你说说，我是怎么解决的 WebView和JS的交互在看接下来的之前咱们需要知道一个知识点就是WKWebVIew和js的交互 let configuration = WKWebViewConfiguration() configuration.userContentController.add(self, name: \"JSBridge\") self.webView = WKWebView(frame: CGRect(origin: CGPoint.zero, size: CGSize(width: 600, height: 1000)), configuration: configuration) 这个JSBridge就是我们自定义的桥连对象，使用这个桥连对象就可以实现交互了 WKWebView -&gt; javaScript的操作 self.webView.evaluateJavaScript(\"js 语句\") { (data, _) in // data 就是反回的数据 } javaScript –&gt; WKWebView的操作 var message = { \"type\": 0 } window.webkit.messageHandlers.JSBridge.postMessage(message); 之后再咱们的项目中实现WKScriptMessageHandler代理方法 public func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { guard let bodyData = message.body as? Dictionary&lt;String,AnyObject> else { return } /// bodyDaya 就是咱们的传入的对象 这里根据自己传入的类型机型 options 判断即可 } 其中JSBridge 对象就是咱们的自定义桥连对象 这样就可以实现交互了 高度的计算问题相信很朋友也都查阅了很多东西，知道了 调用 JS的 高度计算方法 . document.getElementById(&#39;section&#39;).offsetHeight 我的主要内容都是显示在一个 section的Div里的，你们各位也请进行自己的计算。 那好吧，我们就来做吧~~~ 首先我们先监听 WebView 加载完成页面之后的事件，那么我们先实现它的Delegate吧。 /// 加载完成 public func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { // 执行方法 self.webView.evaluateJavaScript(\"document.getElementById('section').offsetHeight\") { (data, _) in if let height = data as? CGFloat{ if self.webView.frame.size.height != height+35 { self.webView.layoutIfNeeded() self.webView.frame.size.height = height+35 self.tableView.tableHeaderView = self.webView } } } } 这样我们会发觉，好了啊~ 那么接下来咱们就遇到了，咱们的第二个坎 图片LazyLoad的问题可能在这里很多用户就会察觉到这个，当咱们的新闻详情很多图片的时候，咱们就会出现加载时间巨长的问题。主要是因为Html界面呢，他不是咱们的tableView,ios的加载机制，是快要显示了开始准备渲染Cell，而Html是全部渲染完成，之后你爱怎么滑怎么滑。所以当图片过大的时候。就会出现加载时间很长的问题了那么自然而然的想到了使用咱们的lazyload。也就是俗称的 懒加载。 现在世面上的懒加载，都是一个样子的，给你提供一个自定义的额属性。比如lazysrc，设置成咱们需要加载的网络图片，而src设置成咱们的没有加载出来的占位图片。之后检测页面的滑动情况，当检测到快或者需要显示&lt;img&gt;标签的时候，进行吧 lazysrc赋值src的这么一个操作。 &lt;script src=\"jquery-1.11.0.min.js\">&lt;/script> &lt;script src=\"jquery.lazyload.js?v=1.9.1\">&lt;/script> 在网上随便找了一个测试发觉没用还是慢啊，之后抓包，发现图片还是一起加载的。即使没有滑动…… 这是怎么回事儿呢？ 其实不难理解，咱们的懒加载计算的是通过偏移位置来计算的，什么事偏移位置呢。。其实这个地方用图的方式更好，但是我不知道用什么画…… 那么咱们给webView的设置的就是咱们的所有的html的高度，他根本就不需要偏移就可以显示所有的内容了，这也就是我们的lazyload.js 没有效果的原因了。那么我们怎么解决这个问题呢？ 我是这样做的，因为我的WebView是tableView的表视图，那么我就实现了 scrollView的代理方法 /** 主要是为了针对于党图片延时加载之后的webvView高度问题 - parameter scrollView: 滑动视图 */ public func scrollViewDidScroll(_ scrollView: UIScrollView) { let height = UIScreen.main.bounds.height+scrollView.contentOffset.y self.webView.evaluateJavaScript(\"scrollMethod(\\(height))\", completionHandler: nil) self.adaptionWebViewHeightMethod() } 通过这个方法不断检测页面的偏移量 function scrollMethod(offesty) { $(\"img\").each(function(index, img) { // &lt;!-- 更多的操作> }) } 在这个操作里进行图片的循环跟我们传入的便宜量对比，如果快要展示了，那么咱们就把咱们设置的 属性替换成图片的src ，这个子就实现了图片的懒加载了 关于图片点击问题这个点击问题，相信大家看到这里就应该已经知道该怎么做了。对了………… 当然是使用js方法桥连了 $(\"#body_section img\").click(function() { var index = $(\"img\").index(this); window.webkit.messageHandlers.JSBridge.postMessage({ \"type\": 1, \"index\": index }); }) public func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { guard let bodyData = message.body as? Dictionary&lt;String,AnyObject> else { return } guard let type = bodyData[\"type\"] as? Int else{return} if type == 1 { /// 图片展示 } } 但是这就又有了一个问题，就是咱们的webview和咱们的图片展示VC的图片加载的方式是不一样的。我这里先讲讲我的，之前找到使用 webview的缓存？还是什么的，还没有研究…… 关于图片重复加载的问题。其实这里的问题，就难点了，我是想了很久，该怎么解决，因为这样还涉及到一个问题，就是给图片添加进度条的问题。 先说说解决办法吧，心路历程就不说了。首先咱们的不是可以控制图片的何时加载了吗？那么咱们可不可以更厉害一点呢？让我们的图片该要加载的时候把请求链接传给我们，我们进行我们的缓存策略。SD PIN 随便了就。 答案是肯定的。 $(\"img\").each(function(index, img) { var datasrc = $(this).attr(\"data-src\") if ($(this).offset().top &lt; offesty + 200 &amp;&amp; ajaxUrl.indexOf(index) == -1) { ajaxUrl.push(index) window.webkit.messageHandlers.JSBridge.postMessage({ \"type\": 3, \"index\": index, \"url\": datasrc }); } }) 其中 ajaxurl存储了已经添加的 index 如果，没有这个东西的话，我们只要一滑动，那就蹭蹭蹭的传递给我们url，我们就有的加载了…… 这可不是我们想要的。 那么在我们接收到URL的加载的请求，那么我们就开始加载吧~~ fileprivate func HandlePinDownLoadResult(_ finish:@escaping (String) -> Void,result:PINRemoteImageManagerResult){ /// 含有静态图片 if let img = result.image ,let base64 = UIImageJPEGRepresentation(img, 0.9)?.base64EncodedString(options: NSData.Base64EncodingOptions.init(rawValue: 0)){ DispatchQueue.global(qos: .background).async { let string = \"data:image/jpeg;base64,\\(base64)\".replaceRegex(\"&lt;\", with: \"\").replaceRegex(\">\", with: \"\") DispatchQueue.main.async(execute: { finish(string) }) } } /// 含有动态图片 if let img = result.animatedImage { DispatchQueue.global(qos: DispatchQoS.QoSClass.background).async { let base64 = img.data.base64EncodedString(options: NSData.Base64EncodingOptions.init(rawValue: 0)) let string = \"data:image/gif;base64,\\(base64)\".replaceRegex(\"&lt;\", with: \"\").replaceRegex(\">\", with: \"\") DispatchQueue.main.async(execute: { finish(string) }) } } } 这样我们就实现了图片的本地缓存策略了~但是问题又来了…… 首先就是遇到大的图片尤其是gif那个base64解析真是慢啊…… 而且每次重新打开 webview 就算是已经下载好了，光是base64解析也要小一会儿了…… base64的问题那还真没好的办法，，缓存吧……………… fileprivate func DownloadImageByUrl(_ progress:@escaping (Int) -> Void,finish:@escaping (String) -> Void){ /// 先读缓存 没有咱们再进行后续工作 if let str = PINCache.shared().object(forKey: \"hanle\\(self)\") as? String { return finish(str) } guard let url = URL(string: self) else { return } PINRemoteImageManager.shared().downloadImage(with: url, options: PINRemoteImageManagerDownloadOptions(), { (result) in self.HandlePinDownLoadResult(finish,result:result) } } /** 处理PINRemoteImage下载完成的结果哦 - parameter finish: 处理完成化后的回调 - parameter result: Result to PINRemoteImageManagerResult */ fileprivate func HandlePinDownLoadResult(_ finish:@escaping (String) -> Void,result:PINRemoteImageManagerResult){ /// 含有静态图片 if let img = result.image ,let base64 = UIImageJPEGRepresentation(img, 0.9)?.base64EncodedString(options: NSData.Base64EncodingOptions.init(rawValue: 0)){ DispatchQueue.global(qos: .background).async { let string = \"data:image/jpeg;base64,\\(base64)\".replaceRegex(\"&lt;\", with: \"\").replaceRegex(\">\", with: \"\") DispatchQueue.main.async(execute: { finish(string) PINCache.shared().setObject(string as NSCoding, forKey: \"hanle\\(self)\") /// 缓存 }) } } /// 含有动态图片 if let img = result.animatedImage { DispatchQueue.global(qos: DispatchQoS.QoSClass.background).async { let base64 = img.data.base64EncodedString(options: NSData.Base64EncodingOptions.init(rawValue: 0)) let string = \"data:image/gif;base64,\\(base64)\".replaceRegex(\"&lt;\", with: \"\").replaceRegex(\">\", with: \"\") DispatchQueue.main.async(execute: { finish(string) PINCache.shared().setObject(string as NSCoding, forKey: \"hanle\\(self)\") /// 缓存 }) } } } 图片加载进度条这个需要html配合，首先咱们每个图片也就是&lt;img&gt;标签上都生成一个进度条。无论什么样子的都行。反正你得保证我把进度传递回去了，你找的到你的空间，那么唯一标识是。index还是其他的随你了。 fileprivate func DownloadImageByUrl(_ progress:@escaping (Int) -> Void,finish:@escaping (String) -> Void){ if let str = PINCache.shared().object(forKey: \"hanle\\(self)\") as? String { return finish(str) } guard let url = URL(string: self) else { return } PINRemoteImageManager.shared().downloadImage(with: url, options: PINRemoteImageManagerDownloadOptions(), progressDownload: { (min, max) in if url.absoluteString.hasSuffix(\".gif\") { let process = Int(CGFloat(min)/CGFloat(max)*100) progress((process-5 &lt; 0 ? 0 : process-5)) } }) { (result) in self.HandlePinDownLoadResult(finish,result:result) } } 这样咱们就获取到了进度了。 /** 根据提供的 URL 和 需要加载完成的 Index - parameter url: 图片URL - parameter index: 图片所在的Index */ fileprivate func HandleUrlAndIndex(_ url:String,index:Int){ url.DownloadImageByUrl({ (pro) in DispatchQueue.main.async(execute: { let jsStr = \"$(\\\"div .customProgressBar\\\").eq(\\(index)).css(\\\"width\\\",\\\"\\(pro)%\\\")\" self.webView.evaluateJavaScript(jsStr, completionHandler: nil) }) }, finish: { (base64) in let jsStr = \"$(\\\"img\\\").eq(\\(index)).attr(\\\"src\\\",\\\"\\(base64)\\\")\" self.webView.evaluateJavaScript(jsStr, completionHandler: nil) if url.hasSuffix(\".gif\") { let display = \"$(\\\"div .progress\\\").eq(\\(index)).css(\\\"visibility\\\",\\\"hidden\\\")\" self.webView.evaluateJavaScript(display, completionHandler: nil) } }) } 我的进度条class都叫做customProgressBar，之后我根据 index 进行的唯一性标识。之后传入过去进度条。进行进度条的显示。 对了提醒一句 进度条特别占内存。咱们还是只给 gif 做做就算了，其他的没必要啊………… 谢谢","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://www.msiter.com/tags/swift/"},{"name":"WKWebView","slug":"WKWebView","permalink":"http://www.msiter.com/tags/WKWebView/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"RxSwift 学习 未完待续","slug":"RxSwift 学习","date":"2016-07-06T21:16:43.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2016/07/06/RxSwift 学习/","link":"","permalink":"http://www.msiter.com/2016/07/06/RxSwift 学习/","excerpt":"简介为什么使用 RxSwift其实这个问题就是在问，RxSwift它可以做什么呢？在他们编写程序的时候，总是会牵涉到需要检测某些值的变化。比如。textFiled Text变化？数据请求完成失败的变化？键盘弹起隐藏的变化，而我们需要做很多不一样的操作，去检测这些东西的变化情况，可能会是delegate，Notifinotion，KVO等等。 于是乎就有人想到了，为什么不设计一种处理机制来统一处理这些东西呢？所以 reactivex 这种机制出现了，而这里的 RxSwift 就是这么一个机制下的一个扩展。所以RxSwift 为什么用它？你可以理解了吗？","text":"简介为什么使用 RxSwift其实这个问题就是在问，RxSwift它可以做什么呢？在他们编写程序的时候，总是会牵涉到需要检测某些值的变化。比如。textFiled Text变化？数据请求完成失败的变化？键盘弹起隐藏的变化，而我们需要做很多不一样的操作，去检测这些东西的变化情况，可能会是delegate，Notifinotion，KVO等等。 于是乎就有人想到了，为什么不设计一种处理机制来统一处理这些东西呢？所以 reactivex 这种机制出现了，而这里的 RxSwift 就是这么一个机制下的一个扩展。所以RxSwift 为什么用它？你可以理解了吗？ RxSwift 概念每一个Observable 的实例相当于一个Swift中的Sequence。 但是区别在于，Swift中的SequenceType是同步的循环，而 Observable 是异步的。 一个 Observable (ObservableType) 相当于一个序列Sequence(SequenceType) . ObservableType.subscribe(_:) 方法其实就相当于 SequenceType.generate() Observable 对象会在有任何 Event 时候，将把 observer (ObserverType) 作为一个参数通过 ObservableType.subscribe(_:) 自动发出。并不需要 observer (ObserverType) 调用 Next()方法 如果一个 Observable 发送了一个 (Event.Next(Element)) 下一步指令的时候，它将会继续发送后续更多的 Event ，然而如果它发出的是一个 (Event.Error(ErrorType)) 错误动作，或者是一个 (Event.Completed) 正常结束完成动作的话。它将通知不在发出任何动作。 序列的语法可以很明显的表达这一点: Next* (Error | Completed)? 图表可以直观的解释这一切 --1--2--3--4--5--6--|----> // \"|\" = 正常终止 --a--b--c--d--e--f--X----> // \"X\" = 错误终止 --tap--tap----------tap--> // \"|\" = 继续进行, 如同一个按钮点击事件的一个序列 这些图表被称为marble diagrams。你可以学习更多关于他们在 rxmarbles.com。 Observables 和 observers (又名 subscribers)Observables 观测数据将不会执行除非有用户用户订阅了它。在下面的示例中，观察到的关闭将永远不会被执行，因为没有订阅observers： example(\"Observable with no subscribers\") { _ = Observable&lt;String>.create { observerOfString -> Disposable in print(\"This will never be printed\") observerOfString.on(.Next(\"😬\")) observerOfString.on(.Completed) return NopDisposable.instance } } 在下面的示例中, 在结束之前会调用 subscribe(_:): example(\"Observable with subscriber\") { _ = Observable&lt;String>.create { observerOfString in print(\"Observable created\") observerOfString.on(.Next(\"😉\")) observerOfString.on(.Completed) return NopDisposable.instance } .subscribe { event in print(event) } } 不用担心这些创建 Observable 的细节，马上就要学习了 在以上的栗子中，我们返回的都是一个 NopDisposable.instance ，而在实际的情况中是需要 返回一个 DisposeBag 的实例的，来妥善的处理这些代码。 至于为什么？嗯。 …… practice makes permanent 🙂 熟能生巧？ 你可以查看更多介绍 Disposing ， Getting Started guide. 创建和订阅一个 Observables有以下这几种方法来创建和订阅一个 Observables never创建一个 Observables ，不发出任何项目，不终止 就是任性！！！！ example(\"never\") { let disposeBag = DisposeBag() let neverSequence = Observable&lt;String>.never() let neverSequenceSubscription = neverSequence .subscribe { _ in print(\"This will never be printed\") } neverSequenceSubscription.addDisposableTo(disposeBag) } empty创建一个只发送完成动作的 Observables 对象。 老子不问过程，只看结果！！！ example(\"empty\") { let disposeBag = DisposeBag() Observable&lt;Int>.empty() .subscribe { event in print(event) } .addDisposableTo(disposeBag) } 这个实例还介绍了创建和订阅一个 Observables 对象，其实就是执行了 subscribe 这个方法。 just创建一个发送制定动作的的 Observables 对象。 example(\"just\") { let disposeBag = DisposeBag() Observable.just(\"🔴\") .subscribe { event in print(event) } .addDisposableTo(disposeBag) } 这个实例还介绍了创建和订阅一个 Observables 对象，其实就是执行了 subscribe 这个方法。 of创建一个具有固定数量的 Observables 对象 example(\"of\") { let disposeBag = DisposeBag() Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\") .subscribeNext { element in print(element) } .addDisposableTo(disposeBag) } 这个例子还介绍了 subscribeNext(:) 这种简单的方法不像 subscribe(:),它是定语了所有的动作 包括 （Next, Error, and Completed）subscribeNext 将会忽略所有的 (Error and Completed )动作，只会生产出一个 Next 动作、我们这里同样也有 完成 和 失败 对应的简单方法。 subscribeError(:) and subscribeCompleted(:)，当你只想检测是对应的动作的时候如果你想订阅所有的动作的你可以使用 subscribe(onNext:onError:onCompleted:onDisposed:)` 就像下面的例子 👇看了以下自己写的。不知道怎么说！ 草 ！subscribe 就是拦截所有的操作！ 比如 next error 和 complted。而这些检测都有单独的简便方法 subscribeNext subscribeError subscribeCompleted Example someObservable.subscribe( onNext: { print(&quot;Element:&quot;, $0) }, onError: { print(&quot;Error:&quot;, $0) }, onCompleted: { print(&quot;Completed&quot;) }, onDisposed: { print(&quot;Disposed&quot;) } ) toObservable将一个 sequence(SequenceType),转换成为一个 Observable ,可以是任何实现了(SequenceType)协议的对象，比如Array, Dictionary, or Set example(\"toObservable\") { let disposeBag = DisposeBag() [\"🐶\", \"🐱\", \"🐭\", \"🐹\"].toObservable() .subscribeNext { print($0) } .addDisposableTo(disposeBag) } 该例子使用了 $0 这一种参数，而不是显式命名的参数 create创建一个 Observable 序列 example(\"create\") { let disposeBag = DisposeBag() let myJust = { (element: String) -> Observable&lt;String> in return Observable.create { observer in observer.on(.Next(element)) observer.on(.Completed) return NopDisposable.instance } } myJust(\"🔴\") .subscribe { print($0) } .addDisposableTo(disposeBag) } range创建一个 可以发射一系列的连续整数，然后终止 的 Observable对象 example(\"range\") { let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .subscribe { print($0) } .addDisposableTo(disposeBag) } repeatElement创建一个无限地发射给定的元素 Observable。 豌豆君？？ example(\"repeatElement\") { let disposeBag = DisposeBag() Observable.repeatElement(\"🔴\") .take(3) .subscribeNext { print($0) } .addDisposableTo(disposeBag) } 该栗子中使用 take 方法来限制发射给定元素的次数 generate创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的 Observable ! 老子 刚正不阿 example(\"generate\") { let disposeBag = DisposeBag() Observable.generate( initialState: 0, condition: { $0 &lt; 3 }, iterate: { $0 + 1 } ) .subscribeNext { print($0) } .addDisposableTo(disposeBag) } deferred创建一个全新的 Observable ，你TM才是搬运工，老子是大自然的创造者！ example(\"deferred\") { let disposeBag = DisposeBag() var count = 1 let deferredSequence = Observable&lt;String>.deferred { print(\"Creating \\(count)\") count += 1 return Observable.create { observer in print(\"Emitting...\") observer.onNext(\"🐶\") observer.onNext(\"🐱\") observer.onNext(\"🐵\") return NopDisposable.instance } } deferredSequence .subscribeNext { print($0) } .addDisposableTo(disposeBag) deferredSequence .subscribeNext { print($0) } .addDisposableTo(disposeBag) } error创建一个不做任何操作，直接丢一个错误给你的 Observable. 对方不想和你 BB，并丢给你一个错误 😐 example(\"error\") { let disposeBag = DisposeBag() Observable&lt;Int>.error(Error.Test) .subscribe { print($0) } .addDisposableTo(disposeBag) } doOn为每一个发出的事件和返回的执行制定操作。 收费站？ example(\"doOn\") { let disposeBag = DisposeBag() Observable.of(\"🍎\", \"🍐\", \"🍊\", \"🍋\") .doOn { print(\"Intercepted:\", $0) } .subscribeNext { print($0) } .addDisposableTo(disposeBag) } 这里也有。 doOnNext(:), doOnError(:), and doOnCompleted(:) 简便方法。 也有 doOn(onNext(:)onError(:)onCompleted(:)) 这样的方法 Working with Subjects使用 Subjects 进行工作，一个 Subject 可以理解为一个中间人，他既可以观察者观察，向观察者提供动作。也可以当作观察者去观察，来接受对象。 大概的意思。可攻可受？？？ PublishSubject向所有订阅者发布动作。在他们订阅之后。这个时间是有关系的哦。从下图也可以看到，第二个订阅的用户，已经错过了接受红绿的时间。所以他只接受到了，蓝色和错误动作 let disposeBag = DisposeBag() let subject = PublishSubject&lt;String>() subject.subscribe{print(\"第一次订阅\",$0)}.addDisposableTo(disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.subscribe{print(\"第二次订阅\",$0)}.addDisposableTo(disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") 在这份代码中第一个订阅可以展示4个？而第二次，就只能接收到 小猫和小狗。 在这份例子中，使用的是 onNext(:) 简便的方法，当然也有 错误 和 完成的简便方法 onError(:) , onCompleted() . 你也可以直接食用 on(.Error(:)) on(.Completed(:)) on(.Next(:)) 这和之前的如出一辙 (:) ReplaySubject咱们之前创建的 PublishSubject ，如果在订阅之前的时间是不会接收到的，而这个呢 可以指定，缓存的个数，比如 2 ，那么咱们就可以接受订阅时间之前两次的 动作事件。 let disposeBag = DisposeBag() let subject = ReplaySubject&lt;String>.create(bufferSize: 1) subject.subscribe{print(\"第一次订阅\",$0)}.addDisposableTo(disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.subscribe{print(\"第二次订阅\",$0)}.addDisposableTo(disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") 在这份代码中，第二次的额订阅的时候 就会 是 小猫 A 和 B了～ BehaviorSubject向所有的订阅者广播新的事件，并且传递 当前 的最新值，初始值。 怎么感觉就是 ReplaySubject 之后 buffSize 是 1 的变形呢。。。。除了多了一个初始值。。。 let disposeBag = DisposeBag() let subject = BehaviorSubject(value: \"🔴\") subject.subscribe{print(\"第一次订阅\",$0) }.addDisposableTo(disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.subscribe{ print(\"第二次订阅\",$0)}.addDisposableTo(disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") 在第二次订阅出现的时候会多出现一次。最新值。而第一次订阅则会出现一个 初始值。 看了这三个例子有没有好像遗漏了什么 ，一个 Completed 事件。 PublishSubject, ReplaySubject, 和 BehaviorSubject 不会在自动发出 完成事件的。 VariableBehaviorSubject 变种。。。 就是说呢，BehaviorSubject 不是不会自动发送 Completed 事件吗？ Variable 会。没了。 let variable = Variable(\"🔴\") subject.subscribe{print(\"第一次订阅\",$0) }.addDisposableTo(disposeBag) variable.value = \"🐶\" variable.value = \"🐱\" subject.subscribe{ print(\"第一次订阅\",$0)}.addDisposableTo(disposeBag) variable.value = \"🅰️\" variable.value = \"🅱️\" Variable 对象 调用 asObservable() 方法可以获取他变种前的 BehaviorSubject 对象。 Variable 对象 不能实现 onNext 方法，但是你可以调用他的 value 参数，来 get 和set 它的值。","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://www.msiter.com/tags/swift/"},{"name":"RX","slug":"RX","permalink":"http://www.msiter.com/tags/RX/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"reactivex 学习","slug":"reactivex 学习","date":"2016-06-21T23:22:00.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2016/06/21/reactivex 学习/","link":"","permalink":"http://www.msiter.com/2016/06/21/reactivex 学习/","excerpt":"散记好久没有学习到新的东西了，之前一直想学习 ReactiveCocoa,但是看了一点之后，觉的很是繁琐，而且感觉很多api方法，再加上项目很紧迫没有时间去学习新的东西了。我就暂时搁置了，现在项目做的也差不多了，觉得这个学习进度是时候提上进程。 再开始学习的时候，发现了RxSwift.在之后发现了 reactivex 。进入了官网发现自己可能，找到了一个 类似于 Realm和swagger 的庞然大物， 绝对要好好学习，在加上自己学习的本身就是swift。自然选择了 RXswift。 好了，废话不多说了，开始学习吧，请耐心看下去。因为我也是翻译，所以如果有任何觉得不应该的地方，可以提醒我。","text":"散记好久没有学习到新的东西了，之前一直想学习 ReactiveCocoa,但是看了一点之后，觉的很是繁琐，而且感觉很多api方法，再加上项目很紧迫没有时间去学习新的东西了。我就暂时搁置了，现在项目做的也差不多了，觉得这个学习进度是时候提上进程。 再开始学习的时候，发现了RxSwift.在之后发现了 reactivex 。进入了官网发现自己可能，找到了一个 类似于 Realm和swagger 的庞然大物， 绝对要好好学习，在加上自己学习的本身就是swift。自然选择了 RXswift。 好了，废话不多说了，开始学习吧，请耐心看下去。因为我也是翻译，所以如果有任何觉得不应该的地方，可以提醒我。 ReactiveX在进入ReactiveX的官方网站后，就看到了它对自己的评价 ReactiveX is a combination of the best ideas fromthe Observer pattern, the Iterator pattern, and functional programming reactivex组合是观察者模式，迭代器模式和函数式编程最好的想法。 ok ~ 好吧，算你吊。什么意思！ Observable 观察者模式简介在reactivex 观察者 订阅 可观察对象。然后，观察者 会对 可观察对象 以任意顺序发出的任何项目丢回作出反应。这种模式有利于并发操作，他不需要创建一个阻塞对象来等待 可观察者 发出任何指令,而是创建一个哨兵的形式的观察员，随时准备作出适当的反应针对于 可观察对象 发出的项目。 See Also Single — 一个针对于可观察对象只发出一次项目的专门版本 Rx Workshop: Introduction Introduction to Rx: IObservable Mastering observables (来自 Couchbase 服务器的文档) 2 minute introduction to Rx 作者: Andre Staltz(“Think of an Observable as an asynchronous immutable array.”) (把一个可观察对象认作为一个异步不可改变的数组) Introducing the Observable by Jafar Husain (JavaScript Video Tutorial) Observable object (RxJS) by Dennis Stoyanov Turning a callback into an Rx Observable by @afterecho Background在许多编程项目中，人们往往更倾向于在一个时间执行一个指令执行或者完成一个增量操作。但是在reactivex中，许多指令可以并行执行。其结果会在后来以任意顺序被观察者抓获。而不是定义一个方法完成数据的转换等操作方法，然后以一个 被观察者的身份去订阅了一个观察者。 这种方法的一个优点是，当你有一堆不依赖于彼此的任务时，你可以同时启动它们，而不是等待每一个完成之前开始下一个-这样，你的总执行时间就是你一堆任务执行时间最长的那一个，就像是木板组成水桶，装的水多少在于最短的那块木板一样的道里。 有许多术语用来描述这种异步编程和设计模型。本文档将使用以下术语：一个观察者订阅观察。一个可观察的发射项目或通过调用观察员的方法发送通知给它的观察员。 在其他情况下，有时也称观察员为“用户”“观看的人”或“堆”。这种模式一般是通常被称为“反应模式” 建立观察员在一个普通的方法调用是异步的，没有排序，并行调用典型的reactivex -流程是这样的： 调用方法。 将该方法的返回值存储在一个变量中 使用这个变量和它的新值来做一些有用的事情。 或者，像这样的： // 打电话，把它的返回值 赋值给` returnval ` returnval =方法（参数）； // returnval 去做点有用的事儿 在异步模型中，流程会像这样： 定义一个方法，做一些有用的从异步调用返回值；该方法是观察者的一部分。也就是 A 调用方法做出一些调整后 反悔 A 定义异步调用方法本身作为一个可观察的对象 附加的观测器，通过订阅它观察（这也导致可观察到的开始行动） 继续你的业务；每当调用返回时，观察者的方法将开始操作它的返回值或值-所观察到的项目。 看起来像这样： // 定义，但不调用，用户 onNext 处理 // 在这个例子中，观察者是非常简单的，只有一个`onNext`处理 def myOnNext = { it -&gt; do something useful with it }; // 定义，但不调用，可观察到的 def myObservable = someObservable(itsParameters); // 订阅用户可见，并调用观察 myObservable.subscribe(myOnNext); // 继续我的业务 onNext, onCompleted, and onError您的观察者实现以下方法的一些订阅方法子集可以将一个观察者连接到一个可观察到的： onNext无论任何时候，一个可观察对象调用这个方法发出一个项目，这个方法会把 被观察者发出的这个项目作为一个参数继续传递下去 onError一个被观察者遇到非预期的数据和一些错误，就会调用这个方法，接下来它不会调用 onCompleted 或者 onNext 方法，这个方法将错误的指示作为参数 onCompleted没有发生错误的情况下，完成操作后，调用的方法。 通过对观察到的条款，它可以调用OnNext零次或更多次，然后可以根据调用结果调用 最后一次 onCompleted或OnError。按照惯例，在这个文件中，调用OnNext通常被称为“排放”的项目，而叫onCompleted或onError被称为“通知”。 参见： Introduction to Rx: IObserver 注销 Unsubscribing在一些reactivex实现，有一个专门的观察者接口，签约者，实现一个Unsubscribing的方法。你可以调用这个方法来表明，用户不再对目前任何订阅感兴趣。这些观测可以（如果他们没有其他感兴趣的观察员）选择停止产生新的物品发出。 这一结果将级联退订通过运营商，适用于观察，观察者订阅的链，这将导致在产业链的各个环节停止发射项目。这不保证立即发生，但是，它是可能的一个观察到的产生和尝试发射一段时间，即使没有观察者仍然观察这些排放量。 关于命名约定的一些注释reactivex每个语言的具体实现有自己的命名习惯。有没有规范的命名标准，虽然有许多共性之间的实现 此外，这些名称中的一些在其他上下文中有不同的含义，或在一个特定的实现语言的成语中显得有些尴尬。 例如有事件的命名模式（例如OnNext，OnCompleted，OnError）。在某些情况下，这样的名称将表示方法，通过该事件处理程序的注册。然而，他们的名字reactivex，事件处理器。 “热”和“冷”的 被观测者什么时候被观察者会发出信息？这取决于被观察者。“热”的观察可能当他刚被创建没多久就发出信息，所以后来订阅的观察者观察到的信息就是中间的某些地方。“冷”的观察，直到一个订阅者观察他的变化，他才开始发生信息。所以观察者就看到他的整个信息过程 在reactivex一些实施方案中，也有一些称为“连接”的观察。除非一个观察者订阅了这个连接对象并且调用它的 Connect 方法，否则被观察者不会发出信息 通过可观察算子的合成观察者和被观察者仅仅只是 ReactiveX的开始。由他们自己，他们只不过是一个轻微的扩展的标准观察者模式，更适合处理一系列的事件，而不是一个单一的回调。 真正的力量来自于reactive extensions（即reactivex）-运营商可以变换，结合，操纵，并与发射的观测值序列的工作项目。 这些接收运营商允许你一起构成异步序列在声明的方式与所有的回调函数的效率效益但没有嵌套的回调处理程序通常与异步系统相关的问题。 This documentation groups information about the various operators and examples of their usage into the following pages: Creating ObservablesCreate, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, and TimerTransforming Observable ItemsBuffer, FlatMap, GroupBy, Map, Scan, and WindowFiltering ObservablesDebounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, and TakeLastCombining ObservablesAnd/Then/When, CombineLatest, Join, Merge, StartWith, Switch, and ZipError Handling OperatorsCatch and RetryUtility OperatorsDelay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, and UsingConditional and Boolean OperatorsAll, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, and TakeWhileMathematical and Aggregate OperatorsAverage, Concat, Count, Max, Min, Reduce, and SumConverting ObservablesToConnectable Observable OperatorsConnect, Publish, RefCount, and ReplayBackpressure Operators执行特定的流量控制策略的各种运营商 连锁运营商大多数操作符在可观察到的和返回一个可观察到的。这允许你应用这些操作符一个接一个，在一个链中。链中的每个操作符都修改了可观察到的结果，从以前的操作的操作。还有其他模式，如生成器模式，其中一个特定类的各种方法通过修改该对象的操作来修改该类的一个类上的一个项目。这些模式也允许你以类似的方式链的方法。但在生成器模式中，在链中出现的方法的顺序通常不重要，与可观察到的运营商的订单事宜。观察到的操作符的链不独立于原始观察到的起源链，但他们反过来操作，每一个操作上的观察所产生的运营商立即在外链。","categories":[{"name":"开发帮助","slug":"开发帮助","permalink":"http://www.msiter.com/categories/开发帮助/"}],"tags":[{"name":"reactiv","slug":"reactiv","permalink":"http://www.msiter.com/tags/reactiv/"},{"name":"rxswift","slug":"rxswift","permalink":"http://www.msiter.com/tags/rxswift/"}],"keywords":[{"name":"开发帮助","slug":"开发帮助","permalink":"http://www.msiter.com/categories/开发帮助/"}]},{"title":"Realm-cocoa 学习","slug":"realm-cocoa 学习","date":"2016-03-03T20:53:35.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2016/03/03/realm-cocoa 学习/","link":"","permalink":"http://www.msiter.com/2016/03/03/realm-cocoa 学习/","excerpt":"PS:以下内容均为项目为Swift的基础，如果需要Object－c请查阅Realm的Object－c文档。 前些日子在看第一届《中国Swift开发者大会》的时候，听到了realm这个数据库，说到了运行速度方面，相较于CoreData可以有很大的提升。再加上之前在做项目的时候，觉的coredata的很多配置让我觉的不爽，很是繁琐。所以就想看一看realm到底如何，学习了一天觉的很好，固决定记录一下。因为也不知道怎么讲解，所以我会尝试翻译realm官网的文档，再加上我的理解进行解释。 Realm is a mobile databasehundreds of millions of people rely on","text":"PS:以下内容均为项目为Swift的基础，如果需要Object－c请查阅Realm的Object－c文档。 前些日子在看第一届《中国Swift开发者大会》的时候，听到了realm这个数据库，说到了运行速度方面，相较于CoreData可以有很大的提升。再加上之前在做项目的时候，觉的coredata的很多配置让我觉的不爽，很是繁琐。所以就想看一看realm到底如何，学习了一天觉的很好，固决定记录一下。因为也不知道怎么讲解，所以我会尝试翻译realm官网的文档，再加上我的理解进行解释。 Realm is a mobile databasehundreds of millions of people rely on 散记这是Realm官网的对于自己的解释。 realm可以快速有效的编写应用程序的本地持久化，它的代码大概就是下面这个样子： // 先创建一个你想要持久化的对象的模型，Object 是 Reaml 自己定义的对象 class Dog: Object { dynamic var name = \"\" dynamic var age = 0 } class Person: Object { dynamic var name = \"\" dynamic var picture: NSData? = nil // 这是一个可选类型 let dogs = List&lt;Dog>() } // 这是实例化一个Realm对象的时候，就像咱们平时创建Class对象一样的 let myDog = Dog() myDog.name = \"Rex\" myDog.age = 1 print(\"name of dog: \\(myDog.name)\") // 得到一个Realm对象 let realm = try! Realm() // 查询这个狗小于两岁的，其实咱们看着代码就可以理解了，它使用了链式代码结构，很容易看懂 let puppies = realm.objects(Dog).filter(\"age &lt; 2\") puppies.count // => 0 比如现在的到的数目是0，因为现在咱们还没有添加任何数据 // 把咱们的上面创建的狗的对象，添加到数据库中 try! realm.write { realm.add(myDog) } // 再次查看数量的时候，不需要再进行一次查询，Realm会自动的为你完成更新 puppies.count // => 1 // 你也可以更新你的数据内容在任何线程 dispatch_async(dispatch_queue_create(\"background\", nil)) { let realm = try! Realm() let theDog = realm.objects(Dog).filter(\"age == 1\").first try! realm.write { theDog!.age = 3 } } 教程项目中如何添加 Realm 框架主要有下面的三种集成方式 使用Dynamic Framework： 下载Realm安装包最新版本 根据你的需要，将你下载文件解压后， 从/ios/swift-2.1.1（IOS设备） 或者 tvos/（Apple电视设备） 再或者 osx/swift-2.1.1/（mac电脑设备） 这三个目录中，选择自己需要的文件，将其拖入项目中，并且要选中“如果需要请勾选”选项 在你的项目中 Build Settings ，为Framework Search Paths 设置ealmSwift.framework 路径 如果使用Realm 在 IOS，watchOS或者TvOS，在Build Phase 创建一个新的 “Run Script Phase”，下面写上bash &quot;${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/Realm.framework/strip-frameworks.sh&quot;这一步是需要解决应用程序商店提交bug时存档通用二进制文件。使用CocoaPods 安装CocoaPods0.39.0 版本或者更新的版本. 在你的Podfile文件中添加use_frameworks! 和 pod &#39;RealmSwift&#39; 在终端中运行 pod install 打开 ＊.xcworkspace 项目使用Carthage 安装 Carthage 0.9.2 或者更新的版本 在你的Cartfile文件中添加&quot;realm/realm-cocoa&quot; 运行 carthage update. 从 Carthage/Build/ 拖拽RealmSwift.framework 和 Realm.framework 到 General 下面的“Embedded Binaries” iOS/watchOS/tvOS: 在你的项目targets的 “Build Phases”设置项中，点击“＋”好按钮，添加一个新的“New Run Script Phase”，内容如下/usr/local/bin/carthage copy-frameworks和路径添加到框架下您想要使用“输入文件”,如$(SRCROOT)/Carthage/Build/iOS/Realm.framework,$(SRCROOT)/Carthage/Build/iOS/RealmSwift.framework这个脚本是在应用程序商店提交错误引发了普遍的二进制文件。确保这一阶段后,“嵌入框架”阶段。 创建数据模型 方便快捷的创建Realm模型首先需要安装Alcatraz,在终端里面执行以下命令.如果执行失败，请翻墙后在尝试 curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh 安装完成之后，重启xcode就可以在菜单window选项下面看到一个Package Manager 选项，点击 安装package ，搜索 Xcode Plugin ，之后，再重启。创建创建文件，就可以文件类型中有一个Realm选项，点击创建。之后生成文件！ 你会发现！！SHIT！！！！！我不如自己写了！！！！！！！ 创建Realm 数据模型其实创建Realm数据模型的方法超级简单，就和咱们平时创建Class是一样一样的。 import RealmSwift // 狗的数据模型 class Dog: Object { dynamic var name = \"\" dynamic var owner: Person? // 狗的主人是可以为空的 } 但是，在们必须知道他都允许咱们创建什么类型的数据。 这样子咱们创建数据模型的时候就没有问题了吧。当然Realm是支持绑定关系的。一对一，一对多之类的，都可以的。 数据的操作 向Realm插入数据终于迎来了，咱们的增删改查了。 当你定义一个模型你可以实例化对象子类和新实例添加到域。考虑一下这个简单的模型: class Dog: Object { dynamic var name = \"\" dynamic var age = 0 } 我们可以以下几个方式创建对象: // (1) 先创建狗的对象，然后在给予其赋值 var myDog = Dog() myDog.name = \"Rex\" myDog.age = 10 // (2) 使用字典创建 let myOtherDog = Dog(value: [\"name\" : \"Pluto\", \"age\": 3]) // (3) 使用一个Array创建y。 let myThirdDog = Dog(value: [\"Fido\", 5]) 1.最显而易见的就是 直接创建对象，并且赋值2.也可以使用字典实例化对象，但是！要使用数据模型中对应的！的键和值。3.最后,可以使用数组实例化对象。但是要注意！数组中的值，必须和数据模型中的属性的顺序保持一致 创建完成对象之后就是把它放入数据库里面了，你可以像下面的方法一样放进数据库 // 创建一个用户对象，并且赋值 let author = Person() author.name = \"David Foster Wallace\" // 得到默认的Realm对象 let realm = try! Realm() // 你只需要这么做一次 // 添加这个对象到Realm try! realm.write { realm.add(author) } 这样就在数据库中，添加了一个对象了。 Realm修改数据Realm 提供很多方式去修改数据，请选择适合自己的方式进行修改 Typed Updates你可以修改任何对象的属性，在write进程中 // Update an object with a transaction try! realm.write { author.name = \"Thomas Pynchon\" } 根据数据的主键进行修改重写数据模型的Object.primaryKey()方法可以设置模型的主键，声明一个主键，允许对象可以通过主键进行有效的查询和修改，并强制每个值的唯一性。一旦一个对象添加到Realm，主键就不能更改 class Book: Object { dynamic var id = 0 dynamic var price = 0 dynamic var title = \"\" override static func primaryKey() -> String? { return \"id\" } } 因为这个数据模型含有主键，所以再向Realm添加一个对象时，如果已经存在同样主键的对象时，Realm会自动更新前一个数据的其它不一样的属性。而如果不存在这个主键的对象，Realm会创建一个新的对象 // 假设Realm中存在一个主键为1的对象的时候 let cheeseBook = Book() cheeseBook.title = \"Cheese recipes\" cheeseBook.price = 9000 cheeseBook.id = 1 // id==1，修改这个书的属性 try! realm.write { realm.add(cheeseBook, update: true) } 你也可以通过一个字典的方式，指定主键和你要修改的属性，来进行修改用户 // 假设数据库中已经存在一个主键为1的Book时 try! realm.write { realm.create(Book.self, value: [\"id\": 1, \"price\": 9000.0], update: true) // the book's `title` property will remain unchanged. } 修改大批量数据可以获取一群数据后，指定这些数据其中的某些数据，或者全部数据。 的某一歇属性值。 let persons = realm.objects(Person) try! realm.write { // 设置第一个人的 isFirst对象为True persons.first?.setValue(true, forKeyPath: \"isFirst\") // 把每个人的所居住的行星，设置为地球 persons.setValue(\"Earth\", forKeyPath: \"planet\") } Realm删除数据当用户想删除某一个对象的时候，查询出来，之后～ // let cheeseBook = ... Book stored in Realm //删除一个对象，在Wirte交易中。 try! realm.write { realm.delete(cheeseBook) } 你也可以删除Realm中的全部数据，这很快速 // 删除Realm中所有的对象 try! realm.write { realm.deleteAll() } Realm查询数据Realm称为这么受欢迎的数据库的原因来了！咱们看她们官方的解释。 Queries return a Results instance, which contains a collection of Objects. Results have an interface very similar to Array and objects contained in a Results can be accessed using indexed subscripting. Unlike Arrays, Results only hold Objects of a single subclass type. 查询返回一个结果实例，它包含一个对象集合。结果类似于Array一样的东西，可以使用下标来进行每一个数据的访问。和Arrays不一样的地方在于,查询结果只持有一种类型的对象。 All queries (including queries and property access) are lazy in Realm. Data is only read when the properties are accessed. 在Realm中，所有的查询（这里面包括了查询和属性的访问）都是懒加载的。数据仅仅在数据访问的时候再进行唯一的一次读取 那么就让我们来试试吧。 let dogs = realm.objects(Dog) // 这样子就查询了Realm数据库中所有的狗 条件筛选如果你熟悉nspredicate，那么你已经到了指导如何查询的境界。对象、Realms，列表，和结果都提供了方法，查询一个结果Arrays 可以传递一个nspredicate实例，谓词字符串，或谓格式字符串。例如，检索所有狗的颜色棕褐色和名字首“B”从默认的境界： // 查询使用谓词字符串 var tanDogs = realm.objects(Dog).filter(\"color = 'tan' AND name BEGINSWITH 'B'\") // 查询使用 NSPredicate 实例 let predicate = NSPredicate(format: \"color = %@ AND name BEGINSWITH %@\", \"tan\", \"B\") tanDogs = realm.objects(Dog).filter(predicate) 看到苹果的谓词编程指南建立谓词的更多信息和使用我们的nspredicate列表。领域支持许多共同的谓词： 比较操作数可以是属性名称或常量。至少一个操作数必须是一个属性名。 比较运算符= =，&lt;，&gt; =，&gt;，！=，支持Int, Int8, Int16, Int32, Int64, Float, Double 和 NSDate 属性类型。如: age == 45 身份比较 == ，!= ，Results&lt;Employee&gt;().filter(&quot;company == %@&quot;, company) 比较运算符 = 和 != 需要Bool属性的支持。 字符串和NSData性质，我们我们支持 ==, !=,BEGINSWITH,CONTAINS, andENDSWITH ，如名称中 CONTAINS ‘Ja’ 不区分大小写的比较字符串，如:CONTAINS[c] ‘Ja’。请注意只有字符A-Z和a-z会被忽略。 Realm支持以下复合操作：: AND, OR, and NOT. 例如：name BEGINSWITH ‘J’ AND age &gt;= 32 包含操作符号 IN， 如 名字 name IN {‘Lisa’, ‘Spike’, ‘Hachi’} 我们可以比较属性是否为空，如：Results&lt;Company&gt;().filter(&quot;ceo == nil&quot;).注意，境界把Nil作为一个特殊的值而不是一个属性的缺失，所以不像SQL零等于本身。 任何的比较，如有 student.age＜21 聚合表达式@count, @min, @max, @sum 和 @avgRealm都支持。例如：realm.objects(Company).filter(&quot;employees.@count &gt; 5&quot;)。找到所有员工在五个以上的公司 子查询的限制和支持： @count在子查询表达式是唯一的。 SUBQUERY(…).@count必须和一个常量进行比较 相关子查询现在还不支持 排序结果允许您在一个或多个属性的基础上指定一个排序标准和顺序。例如，下面的例子中狗按照名字来进行排序返回： let sortedDogs = realm.objects(Dog).filter(\"color = 'tan' AND name BEGINSWITH 'B'\").sorted(\"name\") 链式查询Realm 和其它的查区别在于，他每一个查询结果都拥有继续查询的能力，这样用户就可以对自己查询的结果进行进一步的询问。例如：我们先查找了一群棕色的狗，之后又想查询处其中名字以“B”开头的狗。 let tanDogs = realm.objects(Dog).filter(\"color = 'tan'\") let tanDogsWithBNames = tanDogs.filter(\"name BEGINSWITH 'B'\") Realm版本迁移其实一般的版本迁移有两种情况，第一种。删除了某些字段 class Person: Object { dynamic var firstName = \"\" dynamic var lastName = \"\" dynamic var age = 0 } To: class Person: Object { dynamic var fullName = \"\" dynamic var age = 0 } 接下来，你将进行 // 在你的(application:didFinishLaunchingWithOptions:) let config = Realm.Configuration( // 设置一个新的版本，如果你从来没有设置过版本，那么默认版本就是0 schemaVersion: 1, /// 设置一个找到不一样版本的回调方法 migrationBlock: { migration, oldSchemaVersion in // 因为我们没有设置过版本，所以 oldSchemaVersion &lt; 1 if (oldSchemaVersion &lt; 1) { // 什么都不用做 // Realm 将自动检测新的属性和删除的属性 // 并会自动更新磁盘模式 } }) // 告诉Realm 使用这个新的配置作为默认配置 Realm.Configuration.defaultConfiguration = config // 接下来就让我们获得默认的对象吧 let realm = try! Realm() 而如果你添加了一些字段，比如咱们不想要FirstName和LastName了，我们希望他变成一个字段！fullName！ // 在你的(application:didFinishLaunchingWithOptions:) Realm.Configuration.defaultConfiguration = Realm.Configuration( schemaVersion: 1, migrationBlock: { migration, oldSchemaVersion in if (oldSchemaVersion &lt; 1) { // 枚举所有的属性 migration.enumerate(Person.className()) { oldObject, newObject in // 从旧的对象中获取之前存储的东西 let firstName = oldObject![\"firstName\"] as! String let lastName = oldObject![\"lastName\"] as! String // 设置到新的对象中的属性上去 newObject![\"fullName\"] = \"\\(firstName) \\(lastName)\" } } }) 还有一种情况：从版本0 直接 升到 版本2 Realm.Configuration.defaultConfiguration = Realm.Configuration( schemaVersion: 2, migrationBlock: { migration, oldSchemaVersion in // The enumerateObjects:block: method iterates // over every 'Person' object stored in the Realm file migration.enumerate(Person.className()) { oldObject, newObject in // Add the `fullName` property only to Realms with a schema version of 0 if oldSchemaVersion &lt; 1 { let firstName = oldObject![\"firstName\"] as! String let lastName = oldObject![\"lastName\"] as! String newObject![\"fullName\"] = \"\\(firstName) \\(lastName)\" } // Add the `email` property to Realms with a schema version of 0 or 1 if oldSchemaVersion &lt; 2 { newObject![\"email\"] = \"\" } } }) // Realm will automatically perform the migration and opening the Realm will succeed let realm = try! Realm() Realm数据变化通知结果或列表是通过调用addnotificationblock方法在其数值发生变化的时候给予通知这是可能的。每一次写事务提交时，在其他线程上的其他线程发送通知到其他实例： // 注册通知 let token = realm.addNotificationBlock { notification, realm in viewController.updateUI() } // 稍后 token.stop() 当然你也可以注册某一范围的数值发生变化的时候，进行给予通知 // 大于5岁的人年纪发生变化的时候进行统治 let token = realm.objects(Person).filter(\"age > 5\").addNotificationBlock { results, error in // results 就已经是 `realm.objects(Person).filter(\"age > 5\")`的结果集了 viewController.updateUI() } // 稍后 token.stop() 其它更详细的文档请访问 Realm－Swift文档","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://www.msiter.com/tags/DB/"},{"name":"realm","slug":"realm","permalink":"http://www.msiter.com/tags/realm/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"IOS Tips 小集合","slug":"IOS Tips 小集合","date":"2015-08-10T20:53:35.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2015/08/10/IOS Tips 小集合/","link":"","permalink":"http://www.msiter.com/2015/08/10/IOS Tips 小集合/","excerpt":"IOS技巧，在工作学习中遇到的一些有点意思的小技巧，记录在在这里","text":"IOS技巧，在工作学习中遇到的一些有点意思的小技巧，记录在在这里 代码记录获取状态栏 ///获取状态栏 private func JZStatusBar() -> UIView?{ var object = UIApplication.sharedApplication(),statusBar:UIView? if object.respondsToSelector(NSSelectorFromString(\"statusBar\")) { statusBar = object.valueForKey(\"statusBar\") as? UIView } return statusBar } 动态显示视图///按钮扩展类 @IBDesignable class borderImageView:UIButton{ /// 设置边框宽度 @IBInspectable var borderWidth:CGFloat = 0 { didSet{ self.layer.borderWidth = borderWidth } } /// 设置边框颜色 @IBInspectable var borderColor:UIColor = UIColor.blackColor() { didSet{ self.layer.borderColor = borderColor.CGColor } } /// 设置圆形弧度 @IBInspectable var cornerRadius:CGFloat = 0{ didSet{ self.layer.cornerRadius = cornerRadius } } } 检测键盘弹起隐藏func resignNotification(){ NSNotificationCenter.defaultCenter().addObserver(self, selector: \"keyboardShow:\", name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: \"keyboardHide:\", name: UIKeyboardWillHideNotification, object: nil) } //通知中心通知键盘要出现了！ 😳 全员戒备！ func keyboardShow(note:NSNotification){ if let info = note.userInfo { let keyboardFrame:CGRect = (info[UIKeyboardFrameEndUserInfoKey] as! NSValue).CGRectValue() let deltay:CGFloat = keyboardFrame.size.height as CGFloat self.InputBackViewBottomSpaceConstraint.constant = deltay self.view.layoutIfNeeded() } } //通知中心通知键盘要消失了 😄 解散~ 庆功宴~~ func keyboardHide(note:NSNotification){ self.InputBackViewBottomSpaceConstraint.constant = 0 self.view.layoutIfNeeded() } 单例模式 /// 获取单例模式下的UIStoryBoard对象 class var shareWelComeStoryBoard:UIStoryboard!{ get{ struct backTaskLeton{ static var predicate:dispatch_once_t = 0 static var bgTask:UIStoryboard? = nil } dispatch_once(&amp;backTaskLeton.predicate, { () -> Void in backTaskLeton.bgTask = UIStoryboard(name: \"WelCome\", bundle: NSBundle.mainBundle()) }) return backTaskLeton.bgTask } } 获取当前显示的UIViewControllerextension UIViewController{ class func getCurrentViewController() -> UIViewController?{ if let rootViewController = UIApplication.sharedApplication().keyWindow?.rootViewController{ var topViewController = rootViewController while let present = topViewController.presentedViewController{ topViewController = present } return topViewController } return nil } } /// 调用方法如下 if let currentViewController = UIViewController.getCurrentViewController(){ //// 略 } 判断是否在前台 /// 处于前台 if application.applicationState == UIApplicationState.Active{ /// 处于后台 }else if application.applicationState == UIApplicationState.Inactive{ } 一下子dismiss 两个ViewControllerself.presentingViewController!.presentingViewController?.dismissViewControllerAnimated(true, completion: { () -> Void in }) 第三方导入库下拉刷新BreakOutToRefresh 一个下拉刷新打砖块的swift库SDRefreshView 简单易用的上拉和下拉刷新ZLSwiftRefresh - 下拉刷新/上拉加载更多，支持自定义动画，集成简单GearRefreshControl - 一个非常精细的下拉刷新 做的很细心refresher - 简洁清爽的下拉刷新PullToBounce - 弹性动画 非常炫酷的下拉刷新RCTRefreshControl qq的橡皮糖下拉刷新PullToRefresh 刷新动画可定制的下拉数据请求更新组件MLSwiftBasic 集合自定义导航栏、下拉刷新/上拉加载更多、视觉效果、好用分类等等一系列，却耦合性很低的Swift库! 图片选择、浏览 (这部分swift库真少呀 欢迎知道的补充)PhotoBrowser-swift 图片浏览PhotoPicker swift图片选择BSImagePicker 这个图片选择 不错，oc和swift都有 真贴心呀KYElegantPhotoGallery - 一个优雅的图片浏览库(可惜OC写的呀。。。。)CocoaPicker - 仿 QQ 图片选择器（非swift）。 网络部分Alamofire 著名的 AFNetworking 络基础库 Swift 语言版AlamofireImage 基于 Alamofire 的网络图片组件库Reachability.swift Reachability Swift 版本Ji Swift 版 HTML/XML 解析器CoreStore 提供高可读性，一致性及安全性的 Core Data 管理类库SwiftyJSON GitHub 上最为开发者认可的 JSON 解析类 图片Kingfisher onevcat 大神开发的处理网络图片及缓存的库ImageScout 最小网络代价获得图片大小及类型Nuke 完整、强大、实用的图片管理类库HanekeSwift 轻量带缓存高性能图片加载组件UIImageColors 获取图片张的主色调和其相对应的对比色，背景色之类的框架，可以去看一下，感觉用到的地方还是会很多的 界面效果,动画等awesome-ios-animation 收集了iOS平台下比较主流炫酷的几款动画框架（这上面有很多，孙然不是全部用swift写的。但是还是可以鉴赏下）LiquidFloatingActionButton 可定制水滴型浮动动态按钮组件及演示PNChart-Swift 带动画效果的图表控件库HamburgerButton - Menu/Close 无论设计还是代码，都进行了精雕细琢HamburgerButton - Check Hamburger 风格按钮动画图标（单选）组件entotsu/TKSubmitTransition 登录加载、返回按钮转场动画组件SweetAlert-iOS 带动画效果弹窗封装类Dodo 一款轻量地可定制信息栏小组件AnimatedTabBar 灵动的动画tabbarKYCircularProgress 简单、实用路径可定进程条ParkedTextField 带固定文本的输入组件optonaut/ActiveLabel.swift 扩展实现 UILabel 触控事件针对 “#, @, 链接” 响应GMStepper 带动画效果、支持手势滑动操作的步进标签KSTokenView 带搜索、快捷输入、分段显示关键词输入组件QRCodeReader QR 二维码阅读组件及示例EasyTipView 弹出提示框类及演示示例Popover 泡泡风格弹出视图封装类库TimingFunctionEditor - TimingFunctionEditor用swift编写， 贝塞尔曲线编辑器，编辑后可以预览或拷贝代码片段直接使用。P.S. 该项目采用更简单的依赖管理器Carthage ，而非常用的 CocoaPods。Carthage介绍中文。AAFaceDetection - AAFaceDetection–swift，简单、实用的面部识别封装库。虽然该技术从 iOS 5 发展，不过真正有趣的应用还不多。。Concorde - swift, Concorde, 一个可用于下载和解码渐进式 JPEG 的库, 可用来改善应用的用户体验。ZoomTransition - swift, 通过手势操控图片的放大、缩小、旋转等自由变化效果的组件及示例。AFImageHelper - swift,一套针对 UIImage 和 UIImageView 的实用扩展库，功能包含填色和渐变、裁剪、缩放以及具有缓存机制的在线图片获取PinterestSwift - swift,Pinterest 风格图片缩放、切换示例。NVActivityIndicatorView 等待指示器 真心多。UIViewXXYBoom 模拟MIUI卸载软甲的时候动画TisprCardStack 一款UICollection切换动画LTMorphingLabel 超级炫酷的Label切换文字的动画框架XLPagerTabStrip 多页UIViewControll框架 约束AutolayoutSnapKit 我就用这一个 数据库方面 realm-cocoa 经测试，表示比苹果自带的CoreData 速度更加的快，文档详细。版本迁移方便。 CoreStore 一款CoreData的第三方帮助库，使用CoreData更方面，包括版本迁移。 相机KYShutterButton 模拟系统相机按钮…………TOCropViewController 模拟系统相册剪切图片时的界面MHVideoPhotoGallery 一款可以让你学习到很多知识的demo 其他方面ExSwift 一款Extension集合的框架，省着造轮子了JSQMessagesViewController 聊天页面的搭建，不用愁了～ 但是需要自己去实现一些，例如播放视频之类的东西，它本身只实现了文字和图片STClock 完全模仿锤子时钟，可以当作一个学习的案例","categories":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://www.msiter.com/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://www.msiter.com/tags/swift/"},{"name":"技巧","slug":"技巧","permalink":"http://www.msiter.com/tags/技巧/"}],"keywords":[{"name":"IOS","slug":"IOS","permalink":"http://www.msiter.com/categories/IOS/"}]},{"title":"Swagger 初级学习","slug":"swagger 学习","date":"2015-07-13T18:41:43.000Z","updated":"2017-11-28T11:07:04.831Z","comments":true,"path":"2015/07/13/swagger 学习/","link":"","permalink":"http://www.msiter.com/2015/07/13/swagger 学习/","excerpt":"最开始只是想找一个制作api的工具而已，然后再某一个帖子中发现了这个家伙。他不只是可以让你可以展示服务器的API接口。你甚至可以让客户端受益，生成客户端代码，让客户端开发者直接调用生成代码，使用生成的代码，访问你的接口并且完成数据的获取。So Coll Swagge is a simple yet powerful representation of your RESTful API","text":"最开始只是想找一个制作api的工具而已，然后再某一个帖子中发现了这个家伙。他不只是可以让你可以展示服务器的API接口。你甚至可以让客户端受益，生成客户端代码，让客户端开发者直接调用生成代码，使用生成的代码，访问你的接口并且完成数据的获取。So Coll Swagge is a simple yet powerful representation of your RESTful API swagger的意思是 狂妄自大。但是等我介绍完毕之后你会的觉的他的狂妄绝对是有道理的，没有浮夸。具体来说他是什么呢，正如他自己的介绍，是一个简单而又强大的api发布工具，强大是毋庸置疑的，我现在知道也只是他的几个组件中的几个而已，还有更多的作用的，当然就是这几个作用我就已经获益匪浅了。废话不多说。 本文将从这几个步骤展开讲述： 作为服务器，我们应该如何向后端展示API介绍页面呢 在哪里编写呢？ 怎么编写？ 如何展示？ 仅限NodJs 作为客户端，我们如何获取数据根据Swagger的方式 如何获取? 怎么使用? 仅限swift 在哪里编写呢？两种是，一种是网络编辑器，第二种本地编辑器。如果你哪里的网络没有很差的话，比较推荐使用第一种方式。毕竟简单才是王道 点击这里进入 首先需要你拥有 nodejs 环境，然后执行以下语句 git clone https://github.com/swagger-api/swagger-editor.git cd swagger-editor npm start 其实这两种方式完成之后都会看到编辑页面。当然第一种会简单的很多。打开页面之后你要看看上面的导航栏哦 file自然就是文件的一些操作了，比如新建啊，打开自己的，或者打开魔板啊，之类的。、 Preferences 基本的一些配置，譬如说： 字体大小啊之类的饿，当然也会有其他的设置，但是如果你不是强迫症或者有自己的独特的准则的人，那么这个东西你可以无视 Generate Server 看他的意思也很明白了，生成服务器代码至于你生成什么语言的服务器就看你自己了。 Generate Client 生成客户端代码。很明显啦~ 哇哈哈哈 help - can l help you? 界面怎么编写呢这个就要说起来话就多了，但是我就挑一些重要的吧。毕竟我懒…这里的编辑需要一种模板语言的基础。````yaml使用请打开 【http://editor.swagger.io/#/】 或者 ################################################################################ swagger################################################################################ #这个是必须的swagger: ‘2.0’ ################################################################################ info################################################################################ #文档信息info: title: 遇见 Api description: 遇见 web Service Api 接口。该接口文档用于开发者更好的根据数据，用于遇见用户的记录和遇见用户动态的整合。 version: “1.0.0” termsOfService: Copyright [2015] [一匡天下] license:#可有可无 name: Apache 2.0 url: http://www.apache.org/licenses/LICENSE-2.0.html contact: name: 荆文征 url: msiter.com email: msiter@qq.com API地址host: api.msiter.com 请求方式schemes: http这个字段会添加到所有的API前面，当做版本控制字段还是不错的#basePath: /v1 #MIME类型的api可以产生的列表。这是可以覆盖全球所有API,但在特定的API调用。值必须是所述 http://http://swagger.io/specification/#mimeTypesconsumes: application/json #MIME类型的api可以产生的列表。这是可以覆盖全球所有API,但在特定的API调用。值必须是所述 http://http://swagger.io/specification/#mimeTypesproduces: application/json################################################################################Tags#################################################################################标签，如果你不写的话，他会自动帮你生成的。如果你自己写的话…请注意到咱们的民族。大中国语言毕竟有些不被世界接受，所以难免不好看。还是希望使用英文吧。tags: name: 用户description: | 有关于用户的接口API: 关于注册 关于获取 name: 动态description: | 有关于动态的接口API: 关于创建 关于获取 name: 辅助标签description: | 单纯的为了好看################################################################################ paths#################################################################################接下里就是API主题了paths:/users/registered:post: summary: 注册用户 description: 根据用户传入的新浪微博参数,返回数据库里的用户信息. parameters: name: sourcerequired: truein: querytype: stringformat: stringdescription: 新浪微博 App Id name: access_tokenrequired: truein: querytype: stringformat: stringdescription: 新浪微博 认证口令 name: uidrequired: truein: querytype: stringformat: stringdescription: 新浪微博 用户ID.tags: 用户responses:200:description: 请求完成，获取用户成功schema: $ref: ‘#/definitions/User’400:description: 请求失败schema: $ref: ‘#/definitions/Error’ /users/obtainbyid:get: summary: 根据用户id获取用户信息 description: 根据用户传入的用户id获取用户的信息. parameters: name: masteridrequired: truein: querytype: stringformat: stringdescription: 主人id name: otheridrequired: falsein: querytype: stringformat: stringdescription: 要查询的用户id,如果不传递则查询主人idtags: 用户responses:200:description: 请求完成，获取用户成功schema: $ref: ‘#/definitions/User’400:description: 请求失败schema: $ref: ‘#/definitions/Error’/users/obtainallmeetuser:get:summary: get User By Iddescription: 根据用户id获取用户所有的遇见的人信息.这个接口其实就是获取用户的好友。parameters: name: useridrequired: truein: querytype: stringformat: stringdescription: 用户idtags: 用户responses:200:description: 请求完成，获取用户成功schema: type: array items: $ref: ‘#/definitions/User’400:description: 请求失败schema: $ref: ‘#/definitions/Error’################################################################################Definitions#################################################################################API所需要的模块。definitions:User:description: 用户对象type: objectproperties:_id:type: stringdescription: 用户id.sinaId:type: stringdescription: 新浪微博唯一标示.name:type: stringdescription: 用户名称.gender:type: stringdescription: 用户性别 m：男、f：女、n：未知.commGround:type: stringdescription: 用户常出没地.signature:type: stringdescription: 用户的个性签名.headPhotoKey:type: stringdescription: 七牛的文件访问标示.createDateTime:type: stringformat: date-timedescription: 用户注册时间.userLabels:type: arrayitems:$ref: ‘#/definitions/UserLabel’userBacks:type: arrayitems:$ref: ‘#/definitions/UserBack’UserBack:description: 用户背景对象type: objectproperties:index:type: numberdescription: 用户背景的排序表示.identifier:type: stringdescription: 用户背景的唯一标示.imageKey:type: stringdescription: 七牛的文件访问标示.UserLabel:description: 用户个性签名对象type: objectproperties:content:type: stringdescription: 用户背景的排序表示.identifier:type: stringdescription: 用户背景的唯一标示.createDateTime:type: stringformat: date-timedescription: 七牛的文件访问标示.Error:description: 错误信息properties:error:type: stringdescription: 错误信息. 这个我真的不知道怎么说了，代码复制一下，复制到编辑器内。看看效果对照着来，我相信很快就会学会的。当然人家也是提供了一些示例代码了的，你也可以不看我的这个的。 ### 怎么展示 那就`so Easy`啦，去导航下载你索对应的服务器语言就OK，找不到？ 那么我推荐你使用`NODEJS`。 比如我就是下载的nodejs代码，解压后 cd nodejs-servernpm installnode index.js 然后[点击](http://localhost:8080/docs)不出现什么重大意外，你现在已经处于api页面了。 ### 如何获取? 点击导航内，并下载你所对应的语言 ### 怎么使用? - `swift` 我只知道swift的oc 的类似，其他的语言小弟不曾涉猎。抱歉。 下载完成后，解压后进入后： 1. 如果你使用的`cocopod`,只需要把 文件夹内的`SwaggerClient`文件夹一股脑的拽进你的项目就OK，当然你需要查看一下 `Carfile`文件看看需要引入那些第三方，pod install就可以了。 2. `Carthage`是一个第三方加载组件。我之前因为不知道，直接使用`cocopod`也可以,所以尝试了一番，故记下： - 安装 `Carthage` - 使用 `brew install Carthage` 2. 安装完成后，进入文件目录，`Carthage update` 3. 打开项目，在项目的某个Target -> Build Phases -> Link Library with Libraries，将Carthage/Build目录中希望导入的Framework库拖拽进去。 4. 添加脚本，添加Input Files - 添加脚本 ```/usr/local/bin/carthage copy-frameworks - 添加Input Files ```$(SRCROOT)/Carthage/Build/iOS/你所需要的.framework```","categories":[{"name":"开发帮助","slug":"开发帮助","permalink":"http://www.msiter.com/categories/开发帮助/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://www.msiter.com/tags/swagger/"},{"name":"api","slug":"api","permalink":"http://www.msiter.com/tags/api/"}],"keywords":[{"name":"开发帮助","slug":"开发帮助","permalink":"http://www.msiter.com/categories/开发帮助/"}]},{"title":"Mongoose 学习","slug":"Mongoose 学习","date":"2015-07-11T20:53:35.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2015/07/11/Mongoose 学习/","link":"","permalink":"http://www.msiter.com/2015/07/11/Mongoose 学习/","excerpt":"Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment. 关于mongodb的优势之类的话，我也就不说什么，因为你既然使用这个数据库的话，我相信你已经对他的基本信息很了解了。另外本篇文章没有基本的操作。主要是针对，子表和关联表的操作。因为我觉的基本的操作，不是很麻烦，而遍地都是文档，我感觉没什么必要再叨唠一遍了","text":"Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment. 关于mongodb的优势之类的话，我也就不说什么，因为你既然使用这个数据库的话，我相信你已经对他的基本信息很了解了。另外本篇文章没有基本的操作。主要是针对，子表和关联表的操作。因为我觉的基本的操作，不是很麻烦，而遍地都是文档，我感觉没什么必要再叨唠一遍了 MongoDB 简介MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 数据库操作连接数据库，创建一个表。///获取Mongoose组件 var mongoose = require('mongoose'); ///链接至数据库，Meet则为数据库名称 mongoose.connect('mongodb://localhost/Meet'); 既然已经连接上的话，那么接下来就该是如何创建表了。 var mongoose = require('mongoose'); var UserSchema = new mongoose.Schema({ sinaId: String, name: String, gender: String,//性别，m：男、f：女、n：未知 commGround: String, signature: String, headPhotoKey: String, userBacks: [{ identifier: String, index: Number, imageKey: String }], userLabels: [{ content: String, identifier: String, createDateTime: {type: Date, default: Date.now} }], createDateTime: {type: Date, default: Date.now} }, {collection: \"User\"});///User就是表名了 /** 中间写其他的一些方法 */ var User = mongoose.model('User', UserSchema); 至此 一个表已经创建完成了，可能你会诧异为什么你启动了服务器并且也连接到了数据库却没有创建表，不要着急，你没有数据的时候，数据库是不会显示的。 子表如何操作大家看我接下来的一张表 var UserSchema = new mongoose.Schema({ sinaId: String,//新浪微博ID name: String,//用户名称 gender: String,//性别，m：男、f：女、n：未知 commGround: String,//唱出没地 signature: String,//个性签名 headPhotoKey: String,//头像地址 userLabels: [{//用户个人标签集合 content: String,//内容 identifier: String,//唯一标示 createDateTime: {type: Date, default: Date.now}//创建时间 }], createDateTime: {type: Date, default: Date.now},//用户注册时间 isDelete: {type: Boolean, default: false}//是否删除 }, {collection: \"MeetUser\"}); 这是一个基本的用户数据类型。接下来让我们来看看如何操作这个类型那个吧。 子表新增数据 //创建用户标签方法 UserSchema.statics.createUserLabel = function (userid, identifier, content, createtime, callBack) { //首先查看数据库中该用户是否存在这个个人标签，方法会在下面列出 this.findUserLabel(userid, identifier, function (err, result) { if (result) { if (callBack)return callBack(err, result); return; } //如果并没有该对象，那么久创建一个新德对象 var b = { identifier: identifier, content: content, createDateTime: createtime } //这里就是重点，使用findOneAndUpdate找到高用户，之后使用 $push 新增一个用户个人标签，并且执行 User.findOneAndUpdate({\"_id\": mongoose.Types.ObjectId(userid)}, {'$push': {\"userLabels\": b}}).exec(function (err, result) { ///接口需要所以要在增加完成之后，获取这个用户并且返回 User.findOne({\"_id\": mongoose.Types.ObjectId(userid)}, function (err, result) { callBack(err, result); }); }); }); }; 子表查找数据///该方法就是上面方法中调用的查找方法 UserSchema.statics.findUserLabel = function (userid, identifier, callBack) { this.findOne({ \"_id\": mongoose.Types.ObjectId(userid), \"userLabels.identifier\": identifier }, function (err, result) { if (callBack)return callBack(err, result); }) }; 子表删除数据由于业务上的需要，所以接下来方法是清空该用户所有的个人标签 UserSchema.statics.cleanUserLabels = function (userid, callBack) { ///先找到该用户 this.findOne({\"_id\": mongoose.Types.ObjectId(userid)}, function (err, result) { ///循环遍历用户的个人标签，async 会在另一篇博客中详细讲解 async.map(result.userLabels, function (item, callback) { // 之后使用 $pull 删除用户的个人标签 User.update({\"_id\": mongoose.Types.ObjectId(userid)}, {'$pull': {\"userLabels\": {\"identifier\": item.identifier}}}, function (err, numberUpdated) { callback(null, true) }); }, function (err, results) { if (callBack)return callBack(results.length); }); }); }; 子表修改数据UserSchema.statics.modifysUserLabel = function (userid, identifier,content, callBack) { this.update({ \"_id\": mongoose.Types.ObjectId(userid), \"userLabels.identifier\": identifier }, {'$set': {\"userLabels.$.content\": content}}, function (err, numberUpdated) { User.findById(userid, function (err, data) { if(callBack)callBack(err, data); }); }); }; 以上就是子类的增删改查。希望对你有些许帮助。基本的增删改查，我这里就不多多解释了。 ##关联表如何操作 在mongodb中并没有关联表这么一说，这也是因为mongodb本身就是非关系型数据库，但是mongoose中的populate方法在一定程度上解决了关联问题 首先来查看一些数据库的设计吧。 关联表设计//用户表 var UserSchema = new mongoose.Schema({ name: String }, {collection: \"MeetUser\"}); //加入数据库 var User = mongoose.model('User', UserSchema); //分组表 var GroupSchema = new mongoose.Schema({ name:String, //此时的ref字段要和加入数据库中的model方法内的字段吻合，并且记住一定要写字符串 users:[{type:mongoose.Schema.ObjectId,ref:'User'}] },{collection:\"MeetGroup\"}); var Group = mongoose.model('Group',GroupSchema); 关联表查询方法 GroupSchema.statics.loadGroup = function(callBack){ Group.find().populate('users').exec(callBack); }; 以上是比较基础的查询，但是我们开发的时候遇到的往往没有那么简单，如果我想对字表进行排序或者筛选再或者我只想要子表里的其中一些字段该怎么办呢 关联表准确查询GroupSchema.statics.loadGroup = function(callBack){ var populateQuery = {path:'users',select:'name',match:{ 'name':'Msiter' },options:{ limit:20 },sort:{'_id':1}}; Group.findOne({name:\"Test\"}).select('name users').populate(populateQuery).exec(callBack); }; 其中 Path字段是指要查询的 哪一个 关联表，select 则是需要字表的那些字段 ，如果需要多个 中间一个 空格分隔即可，_id字段是默认被需要的。match就是对关联表的这些筛选的，options就可以使用分页参数 Skip和limit了 当然也有一些常见的查询参数譬如Sort等； 关联表的增加呢？///这里的Userid时mongoose.Schema.ObjectId，即你要关联的对象的Id GroupSchema.statics.createGroup = function(groupname,userId,callBack){ var group = new Group({name:groupname}); group.users.push(userId); group.save(callBack); }; 关联表的删除///这里的Userid时mongoose.Schema.ObjectId，即你要关联的对象的Id GroupSchema.statics.createGroup = function(groupname,userId,callBack){ var group = new Group({name:groupname}); group.users.pull(userId); group.save(callBack); };","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://www.msiter.com/tags/mongodb/"},{"name":"mongoose","slug":"mongoose","permalink":"http://www.msiter.com/tags/mongoose/"},{"name":"nodejs","slug":"nodejs","permalink":"http://www.msiter.com/tags/nodejs/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}]},{"title":"Nodejs Async 学习","slug":"Nodejs Async 学习","date":"2015-07-06T18:41:43.000Z","updated":"2017-11-28T11:07:04.827Z","comments":true,"path":"2015/07/06/Nodejs Async 学习/","link":"","permalink":"http://www.msiter.com/2015/07/06/Nodejs Async 学习/","excerpt":"本文整理于bsspirit的博文和代码示例 Async是一个流程控制工具包，提供了直接而强大的异步功能。基于Javascript为Node.js设计，同时也可以直接在浏览器中使用。Async提供了大约20个函数，包括常用的map,reduce, filter, forEach 等，异步流程控制模式包括，串行(series)，并行(parallel)，瀑布(waterfall)等。","text":"本文整理于bsspirit的博文和代码示例 Async是一个流程控制工具包，提供了直接而强大的异步功能。基于Javascript为Node.js设计，同时也可以直接在浏览器中使用。Async提供了大约20个函数，包括常用的map,reduce, filter, forEach 等，异步流程控制模式包括，串行(series)，并行(parallel)，瀑布(waterfall)等。 项目简介Async For Async v1.5.x documentation, go HERE Async is a utility module which provides straight-forward, powerful functionsfor working with asynchronous JavaScript. Although originally designed foruse with Node.js and installable via npm install --save async,it can also be used directly in the browser. Async is also installable via: bower: bower install async component: component install caolan/async jam: jam install async Async provides around 70 functions that include the usual ‘functional’suspects (map, reduce, filter, each…) as well as some common patternsfor asynchronous control flow (parallel, series, waterfall…). All thesefunctions assume you follow the Node.js convention of providing a singlecallback as the last argument of your asynchronous function – a callback which expects an Error as its first argument – and calling the callback once. 功能简介 集合:Collections each: 如果想对同一个集合中的所有元素都执行同一个异步操作。 map: 对集合中的每一个元素，执行某个异步操作，得到结果。所有的结果将汇总到最终的callback里。与each的区别是，each只关心操作不管最后的值，而map关心的最后产生的值。 filter: 使用异步操作对集合中的元素进行筛选, 需要注意的是，iterator的callback只有一个参数，只能接收true或false。 reject: reject跟filter正好相反，当测试为true时则抛弃 reduce: 可以让我们给定一个初始值，用它与集合中的每一个元素做运算，最后得到一个值。reduce从左向右来遍历元素，如果想从右向左，可使用reduceRight。 detect: 用于取得集合中满足条件的第一个元素。 sortBy: 对集合内的元素进行排序，依据每个元素进行某异步操作后产生的值，从小到大排序。 some: 当集合中是否有至少一个元素满足条件时，最终callback得到的值为true，否则为false. every: 如果集合里每一个元素都满足条件，则传给最终回调的result为true，否则为false concat: 将多个异步操作的结果合并为一个数组。 流程控制: Control Flow concat: 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。 parallel: 并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。 whilst: 相当于while，但其中的异步调用将在完成后才会进行下一次循环。 doWhilst: 相当于do…while, doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。 until: until与whilst正好相反，当test为false时循环，与true时跳出。其它特性一致。 doUntil: doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。 forever: 无论条件循环执行，如果不出错，callback永远不被执行。 waterfall: 按顺序依次执行一组函数。每个函数产生的值，都将传给下一个。 compose: 创建一个包括一组异步函数的函数集合，每个函数会消费上一次函数的返回值。把f(),g(),h()异步函数，组合成f(g(h()))的形式，通过callback得到返回值。 applyEach: 实现给一数组中每个函数传相同参数，通过callback返回。如果只传第一个参数，将返回一个函数对象，我可以传参调用。 queue: 是一个串行的消息队列，通过限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。 cargo: 一个串行的消息队列，类似于queue，通过限制了worker数量，不再一次性全部执行。不同之处在于，cargo每次会加载满额的任务做为任务单元，只有任务单元中全部执行完成后，才会加载新的任务单元。 auto: 用来处理有依赖关系的多个任务的执行。 iterator: 将一组函数包装成为一个iterator，初次调用此iterator时，会执行定义中的第一个函数并返回第二个函数以供调用。 apply: 可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。 nextTick: 与nodejs的nextTick一样，再最后调用函数。 times: 异步运行,times可以指定调用几次，并把结果合并到数组中返回 timesSeries: 与time类似，唯一不同的是同步执行 工具类: Utils memoize: 让某一个函数在内存中缓存它的计算结果。对于相同的参数，只计算一次，下次就直接拿到之前算好的结果。 unmemoize: 让已经被缓存的函数，返回不缓存的函数引用。 log: 执行某异步函数，并记录它的返回值，日志输出。 dir: 与log类似，不同之处在于，会调用浏览器的console.dir()函数，显示为DOM视图。 noConflict: 如果之前已经在全局域中定义了async变量，当导入本async.js时，会先把之前的async变量保存起来，然后覆盖它。仅仅用于浏览器端，在nodejs中没用，这里无法演示。 代码演示 apply代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。 * * function(callback) { t.inc(3, callback); } * 等价于： * async.apply(t.inc, 3); */ // apply(function, arguments..) /** * 通过名字绑定函数t.inc, t.fire，作为新函数给parallel调用 */ //1.1 async.parallel([ async.apply(t.inc, 3), async.apply(t.fire, 100) ], function (err, results) { log('1.1 err: ', err); log('1.1 results: ', results); }); //58.605> 1.1 err: null //58.613> 1.1 results: [ 4, 100 ] /** * 构造一个加法函数，通过apply简化代码 */ //1.2 function inc(a,b,callback,timeout){ var timeout = timeout || 200; t.wait(200); setTimeout(function() { callback(null, a+b); }, timeout); } var fn = async.apply(inc, 1, 2); fn(function(err, n){ log('1.2 inc: ' + n); }); //58.616> 1.2 inc: 3 applyEach代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * applyEach，可以实现给一数组中每个函数传相同参数，通过callback返回。 * 如果只传第一个参数，将返回一个函数对象，我可以传参调用。 */ // applyEach(fns, args..., callback) /** * 异步执行，给数组中的函数，他们有相同的参数。 */ //1.1 async.applyEach([ function (name,cb) { setTimeout(function () { log(\"1.1 handler: \" + name + \" A\"); cb(null, name); }, 500); }, function (name,cb) { setTimeout(function () { log(\"1.1 handler: \" + name + \" B\"); cb(null, name); }, 150); } ], 'Hello', function (err) { log('1.1 err: ', err); }); //06.739> 1.1 handler: Hello B //07.079> 1.1 handler: Hello A //07.080> 1.1 err: null /** * 异步执行，当只设置第一参数后，得到函数对象，再传参调用这个函数。 */ //1.2 var fn = async.applyEach([ function (name,cb) { setTimeout(function () { log(\"1.2 handler: \" + name + \" A\"); }, 500); }, function (name,cb) { setTimeout(function () { log(\"1.2 handler: \" + name + \" B\"); }, 150); } ]); fn(\"simgle\",function(err){ log('err: ',err); }); //29.351> 1.2 handler: simgle B //29.688> 1.2 handler: simgle A /** * applyEachSeries与applyEach唯一不同的是，数组的函数同步执行。 */ //applyEachSeries(arr, args..., callback) //1.3 async.applyEachSeries([ function (name,cb) { setTimeout(function () { log(\"1.3 handler: \" + name + \" A\"); cb(null, name); }, 500); }, function (name,cb) { setTimeout(function () { log(\"1.3 handler: \" + name + \" B\"); cb(null, name); }, 150); } ], \"aaa\", function (err) { log('1.3 err: ', err); }); //10.669> 1.3 handler: aaa A //10.831> 1.3 handler: aaa B //10.834> 1.3 err: null auto代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * auto用来处理有依赖关系的多个任务的执行。 * * 比如某些任务之间彼此独立，可以并行执行；但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。 * 虽然我们可以使用parallel和series结合起来实现该功能，但如果任务之间关系复杂，则代码会相当复杂，以后如果想添加一个新任务，也会很麻烦。 * 这时使用auto，则会事半功倍。 * * 如果有任务中途出错，则会把该错误传给最终callback，所有任务（包括已经执行完的）产生的数据将被忽略。 * 如果不关心错误和最终数据，可以不用写最后那个callback。 */ // async.auto(tasks, [callback]) /** * 我要写一个程序，它要完成以下几件事： * 1. 从某处取得数据 * 2. 在硬盘上建立一个新的目录 * 3. 将数据写入到目录下某文件 * 4. 发送邮件，将文件以附件形式发送给其它人。 * * 分析该任务，可以知道1与2可以并行执行，3需要等1和2完成，4要等3完成。 * 可以按以下方式来使用auto函数。 */ // 1.1 async.auto({ getData: function (callback) { setTimeout(function(){ console.log('1.1: got data'); callback(null, 'mydata'); }, 300); }, makeFolder: function (callback) { setTimeout(function(){ console.log('1.1: made folder'); callback(null, 'myfolder'); }, 200); }, writeFile: ['getData', 'makeFolder', function(callback) { setTimeout(function(){ console.log('1.1: wrote file'); callback(null, 'myfile'); }, 300); }], emailFiles: ['writeFile', function(callback, results) { log('1.1: emailed file: ', results.writeFile); callback(null, results.writeFile); }] }, function(err, results) { log('1.1: err: ', err); log('1.1: results: ', results); }); //1.1: made folder //1.1: got data //1.1: wrote file //20.120> 1.1: emailed file: myfile //20.125> 1.1: err: null //20.127> 1.1: results: { makeFolder: 'myfolder', // getData: 'mydata', // writeFile: 'myfile', // emailFiles: 'myfile' } /** * 如果中途出错，则会把错误交给最终callback，执行完任务的传给最终callback。未执行完成的函数值被忽略 */ // 1.2 async.auto({ getData: function (callback) { setTimeout(function(){ console.log('1.2: got data'); callback(null, 'mydata'); }, 300); }, makeFolder: function (callback) { setTimeout(function(){ console.log('1.2: made folder'); callback(null, 'myfolder'); }, 200); }, writeFile: ['getData', 'makeFolder', function(callback, results) { setTimeout(function(){ console.log('1.2: wrote file'); callback('myerr'); }, 300); }], emailFiles: ['writeFile', function(callback, results) { console.log('1.2: emailed file: ' + results.writeFile); callback('err sending email', results.writeFile); }] }, function(err, results) { log('1.2 err: ', err); log('1.2 results: ', results); }); //1.2: made folder //1.2: got data //1.2: wrote file //51.399> 1.2 err: myerr //51.401> 1.2 results: { makeFolder: 'myfolder', // getData: 'mydata', // writeFile: undefined } cargo代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * cargo也是一个串行的消息队列，类似于queue，通过限制了worker数量，不再一次性全部执行。 * 当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。 * * cargo的不同之处在于，cargo每次会加载满额的任务做为任务单元，只有任务单元中全部执行完成后，才会加载新的任务单元。 */ // cargo(worker, [payload]) /** * 创建cargo实例 */ var cargo = async.cargo(function (tasks, callback) { for(var i=0; i&lt;tasks.length; i++){ log('start ' + tasks[i].name); } callback(); }, 2); /** * 监听：如果某次push操作后，任务数将达到或超过worker数量时，将调用该函数 */ cargo.saturated = function() { log('all workers to be used'); } /** * 监听：当最后一个任务交给worker时，将调用该函数 */ cargo.empty = function() { log('no more tasks wating'); } /** * 监听：当所有任务都执行完以后，将调用该函数 */ cargo.drain = function() { log('all tasks have been processed'); } /** * 增加新任务 */ cargo.push({name: 'A'}, function (err) { t.wait(300); log('finished processing A'); }); cargo.push({name: 'B'}, function (err) { t.wait(600); log('finished processing B'); }); cargo.push({name: 'C'}, function (err) { t.wait(500); log('finished processing C'); }); cargo.push({name: 'D'}, function (err) { t.wait(100); log('finished processing D'); }); cargo.push({name: 'E'}, function (err) { t.wait(200); log('finished processing E'); }); //40.016> all workers to be used //40.020> no more tasks wating //40.020> start A //40.020> start B //40.322> finished processing A //40.923> finished processing B //40.923> no more tasks wating //40.924> start C //40.924> start D //41.425> finished processing C //41.526> finished processing D //41.526> no more tasks wating //41.527> start E //41.728> finished processing E //41.728> all tasks have been processed //41.729> all tasks have been processed //41.729> all tasks have been processed //41.729> all tasks have been processed //41.730> all tasks have been processed compose代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 创建一个包括一组异步函数的函数集合，每个函数会消费上一次函数的返回值。 * 把f(),g(),h()异步函数，组合成f(g(h()))的形式，通过callback得到返回值。 */ // compose(fn1, fn2...) /** * 通过compose组合，f(g(h()))的形式，从内层到外层的执行的顺序。 */ //1.1 function f(n,callback){ log('1.1.f enter: ',n); setTimeout(function () { callback(null, n + 1); }, 10); } function g(n, callback) { log('1.1.g enter: ',n); setTimeout(function () { callback(null, n * 2); }, 10); } function h(n, callback) { log('1.1.h enter: ',n); setTimeout(function () { callback(null, n - 10); }, 10); } var fgh = async.compose(f,g,h); fgh(4,function(err,result){ log('1.1 err: ', err); log('1.1 result: ', result); }); //05.307> 1.1.h enter: 4 //05.329> 1.1.g enter: -6 //05.341> 1.1.f enter: -12 //05.361> 1.1 err: null //05.362> 1.1 result: -11 concat代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 将多个异步操作的结果合并为一个数组。 */ // concat(arr, iterator(item,callback(err,result)), callback(err,result)) var data = { aaa: [11,22,33], bbb: [44,55], ccc: 66 }; var keys = [ {name: 'aaa', delay: 300}, {name: 'bbb', delay: 100}, {name: 'ccc', delay: 200} ]; /** * 以并行方式对集合中各元素进行异步操作，然后把得到的结果合并为一个数组，传给最后的callback。 */ // 1.1 async.concat(keys, function(key,callback) { setTimeout(function() { callback(null, data[key.name]); }, key.delay); }, function(err, values) { log('1.1 err: ', err); log('1.1 values: ', values); }); // 13.539> 1.1 err: // 13.539> 1.1 values: [ 44, 55, 66, 11, 22, 33 ] /** * 如果中途出错，则把错误以及已经完成的操作的结果交给最后callback。未执行完的则忽略。 */ // 1.2 async.concat(keys, function(key,callback) { setTimeout(function() { if(key.name==='ccc') callback('myerr'); else callback(null, data[key.name]); }, key.delay); }, function(err, values) { log('1.2 err: ', err); log('1.2 values: ', values); }); // 13.439> 1.2 err: myerr // 13.439> 1.2 values: [ 44, 55 ] /** * 按数组中的元素顺序来执行异步操作，一个完成后才对下一个进行操作。所有结果会汇集成一个数组交给最后的callback。 */ // concatSeries(arr, iterator, callback) // 1.3 async.concatSeries(keys, function(key,callback) { setTimeout(function() { callback(null, data[key.name]); }, key.delay); }, function(err, values) { log('1.3 err: ', err); log('1.3 values: ', values); }); // 13.859> 1.3 err: // 13.859> 1.3 values: [ 11, 22, 33, 44, 55, 66 ] detect代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 用于取得集合中满足条件的第一个元素。 * 它分为并行与顺序执行两种方式，分别对应函数detect和detectSeries。 */ // detect(array, iterator(item,callback(test)), callback(result) var arr = [ {value:1,delay:500}, {value:2,delay:200}, {value:3,delay:300} ]; /** * 并行执行，通过t.inc做一个累加器，得到第一个满足条件的结果对象 */ async.detect(arr, function(item,callback){ log('1.1 enter: ', item.value); t.inc(item.value, function(err,n) { log('1.1 handle: ', item.value); callback(n%2===0); }, item.delay); }, function(result) { log('1.1 result: ', result); }); // 09.928> 1.1 enter: 1 // 09.928> 1.1 enter: 2 // 09.928> 1.1 enter: 3 // 10.138> 1.1 handle: 2 // 10.228> 1.1 handle: 3 // 10.228> 1.1 result: { value: 3, delay: 300 } // 10.438> 1.1 handle: 1 // 10.438> 1.1 handle: 1 /** * 串行执行，通过t.inc做一个累加器，得到第一个满足条件的结果对象 */ async.detectSeries(arr, function(item,callback) { log('1.2 enter: ', item.value); t.inc(item.value, function(err,n) { log('1.1 handle: ', item.value); callback(n%2===0); }, item.delay); }, function(result) { log('1.2 result: ', result); }); // 09.928> 1.2 enter: 1 // 10.438> 1.2 result: { value: 1, delay: 500 } each代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 如果想对同一个集合中的所有元素都执行同一个异步操作，可以利用each函数。 * * async提供了三种方式： * 1. 集合中所有元素并行执行 * 2. 一个一个顺序执行 * 3. 分批执行，同一批内并行，批与批之间按顺序 * * 如果中途出错，则错误将上传给最终的callback处理。其它已经启动的任务继续执行，未启动的忽略。 */ // each(arr, iterator(item, callback), callback(err)) var arr = [{name:'Jack', delay: 200}, {name:'Mike', delay: 100}, {name:'Freewind', delay: 300}]; /** * 所有操作并发执行，且全部未出错，最终得到的err为undefined。注意最终callback只有一个参数err。 */ // 1.1 async.each(arr, function(item, callback) { log('1.1 enter: ' + item.name); setTimeout(function(){ log('1.1 handle: ' + item.name); callback(null, item.name); }, item.delay); }, function(err) { log('1.1 err: ' + err); }); // 输出如下： // 42.244> 1.1 enter: Jack // 42.245> 1.1 enter: Mike // 42.245> 1.1 enter: Freewind // 42.350> 1.1 handle: Mike // 42.445> 1.1 handle: Jack // 42.554> 1.1 handle: Freewind // 42.554> 1.1 err: undefined /** * 如果中途出错，则出错后马上调用最终的callback。其它未执行完的任务继续执行。 */ async.each(arr,function(item, callback) { log('1.2 enter: ' +item.name); setTimeout(function() { log('1.2 handle: ' + item.name); if(item.name==='Jack') { callback('myerr'); } }, item.delay); }, function(err) { log('1.2 err: ' + err); }); // 输出如下： // 42.246> 1.2 enter: Jack // 42.246> 1.2 enter: Mike // 42.246> 1.2 enter: Freewind // 42.350> 1.2 handle: Mike // 42.445> 1.2 handle: Jack // 42.446> 1.2 err: myerr // 42.555> 1.2 handle: Freewind /** * 与each相似，但不是并行执行。而是一个个按顺序执行。 */ async.eachSeries(arr, function(item, callback) { log('1.3 enter: ' + item.name); setTimeout(function(){ log('1.3 handle: ' + item.name); callback(null, item.name); }, item.delay); }, function(err) { log('1.3 err: ' + err); }); // 42.247> 1.3 enter: Jack // 42.459> 1.3 handle: Jack // 42.459> 1.3 enter: Mike // 42.569> 1.3 handle: Mike // 42.569> 1.3 enter: Freewind // 42.883> 1.3 handle: Freewind // 42.883> 1.3 err: undefined /** * 如果中途出错，则马上把错误传给最终的callback，还未执行的不再执行。 */ async.eachSeries(arr,function(item, callback) { log('1.4 enter: ' +item.name); setTimeout(function() { log('1.4 handle: ' + item.name); if(item.name==='Jack') { callback('myerr'); } }, item.delay); }, function(err) { log('1.4 err: ' + err); }); // 42.247> 1.4 enter: Jack // 42.460> 1.4 handle: Jack // 42.460> 1.4 err: myerr /** * 分批执行，第二个参数是每一批的个数。每一批内并行执行，但批与批之间按顺序执行。 */ async.eachLimit(arr, 2, function(item, callback) { log('1.5 enter: ' + item.name); setTimeout(function(){ log('1.5 handle: ' + item.name); callback(null, item.name); }, item.delay); }, function(err) { log('1.5 err: ' + err); }); // 42.247> 1.5 enter: Jack // 42.248> 1.5 enter: Mike // 42.351> 1.5 handle: Mike // 42.352> 1.5 enter: Freewind // 42.461> 1.5 handle: Jack // 42.664> 1.5 handle: Freewind // 42.664> 1.5 err: undefined /** * 如果中途出错，错误将马上传给最终的callback。同一批中的未执行完的任务还将继续执行，但下一批及以后的不再执行。 */ async.eachLimit(arr,2,function(item, callback) { log('1.6 enter: ' +item.name); setTimeout(function() { log('1.6 handle: ' + item.name); if(item.name==='Jack') { callback('myerr'); } }, item.delay); }, function(err) { log('1.6 err: ' + err); }); // 42.248> 1.6 enter: Jack // 42.248> 1.6 enter: Mike // 42.352> 1.6 handle: Mike // 42.462> 1.6 handle: Jack // 42.462> 1.6 err: myerr every代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 如果集合里每一个元素都满足条件，则传给最终回调的result为true，否则为false */ // every(arr, iterator(item,callback), callback(result)) //alias: all var arr = [1,2,3,6]; /** * 串行执行，集合中所有的元素都&lt;=10，所以为true */ async.every(arr, function(item,callback){ log('1.1 enter: ',item); setTimeout(function(){ log('1.1 handle: ',item); callback(item&lt;=10); },100); }, function(result) { log('1.1 result: ', result); }); // 32.113> 1.1 enter: 1 // 32.123> 1.1 enter: 2 // 32.123> 1.1 enter: 3 // 32.123> 1.1 enter: 6 // 32.233> 1.1 handle: 1 // 32.233> 1.1 handle: 2 // 32.233> 1.1 handle: 3 // 32.233> 1.1 handle: 6 // 32.233> 1.1 result: true /** * 串行执行，集合中至少有一个元素不大于2，所以为false */ async.every(arr, function(item,callback){ log('1.2 enter: ',item); setTimeout(function(){ log('1.2 handle: ',item); callback(item>2); },100); }, function(result) { log('1.2 result: ', result); }); // 32.123> 1.2 enter: 1 // 32.123> 1.2 enter: 2 // 32.123> 1.2 enter: 3 // 32.123> 1.2 enter: 6 // 32.233> 1.2 handle: 1 // 32.233> 1.2 result: false // 32.233> 1.2 handle: 2 // 32.233> 1.2 handle: 3 // 32.233> 1.2 handle: 6 filter 和 reject代码演示 var async = require('async'); var t = require('./t'); var log = t.log; /** * 使用异步操作对集合中的元素进行筛选。需要注意的是，iterator的callback只有一个参数，只能接收true或false。 * * 对于出错，该函数没有做出任何处理，直接由nodejs抛出。所以需要注意对Error的处理。 * * async提供了两种方式： * 1. 并行执行：filter * 2. 顺序执行：filterSereis */ // filter(arr, iterator(item, callback(test)), callback(results)) var arr = [1,2,3,4,5]; /** * 并行执行，对arr进行筛选。 */ async.filter(arr, function(item, callback) { log('1.1 enter: ' + item); setTimeout(function() { log('1.1 test: ' + item); callback(item>=3); }, 200); }, function(results) { log('1.1 results: ', results); }); //16.739> 1.1 enter: 1 //16.749> 1.1 enter: 2 //16.749> 1.1 enter: 3 //16.749> 1.1 enter: 4 //16.749> 1.1 enter: 5 //16.749> 1.3 enter: 1 //16.949> 1.1 test: 1 //16.949> 1.1 test: 2 //16.949> 1.1 test: 3 //16.949> 1.1 test: 4 //16.949> 1.1 test: 5 //16.949> 1.1 results: [ 3, 4, 5 ] /** * 如果出错，将会由nodejs抛出，导致出错。为保证其它代码正常运行，注释掉该测试。 * * try..catch：抓不到这个错误 */ /* async.filter(arr, function(item, callback) { log('1.2 enter: ' + item); setTimeout(function() { log('1.2 handle: ' + item); if(item===2) { throw new Error('myerr'); } callback(item>=3); }, 100); }, function(results) { log('1.2 results: ', results); }); */ /** * 串行执行，对arr进行筛选。 */ // 1.3 async.filterSeries(arr, function(item, callback) { log('1.3 enter: ' + item); setTimeout(function() { log('1.3 handle: ' + item); callback(item>=3); }, 200); }, function(results) { log('1.3 results: ', results); }); // 16.749> 1.3 enter: 1 // 16.949> 1.3 handle: 1 // 16.949> 1.3 enter: 2 // 17.149> 1.3 handle: 2 // 17.149> 1.3 enter: 3 // 17.369> 1.3 handle: 3 // 17.369> 1.3 enter: 4 // 17.589> 1.3 handle: 4 // 17.589> 1.3 enter: 5 // 17.789> 1.3 handle: 5 // 17.789> 1.3 results: [ 3, 4, 5 ] /* * reject跟filter正好相反，当测试为true时，抛弃之 */ // reject(arr, iterator(item, callback(test)), callback(results) async.reject(arr, function(item, callback) { log('1.4 enter: ' + item); setTimeout(function() { log('1.4 test: ' + item); callback(item>=3); }, 200); }, function(results) { log('1.4 results: ', results); }); // 31.359> 1.4 enter: 1 // 31.359> 1.4 enter: 2 // 31.359> 1.4 enter: 3 // 31.359> 1.4 enter: 4 // 31.359> 1.4 enter: 5 // 31.559> 1.4 test: 1 // 31.559> 1.4 test: 2 // 31.559> 1.4 test: 3 // 31.559> 1.4 test: 4 // 31.559> 1.4 test: 5 // 31.569> 1.4 results: [ 1, 2 ] /** * 串行执行，对arr进行筛选。 */ // 1.3 async.rejectSeries(arr, function(item, callback) { log('1.5 enter: ' + item); setTimeout(function() { log('1.5 handle: ' + item); callback(item>=3); }, 200); }, function(results) { log('1.5 results: ', results); }); //43.592> 1.5 enter: 1 //43.799> 1.5 handle: 1 //43.800> 1.5 enter: 2 //44.004> 1.5 handle: 2 //44.007> 1.5 enter: 3 //44.210> 1.5 handle: 3 //44.211> 1.5 enter: 4 //44.412> 1.5 handle: 4 //44.413> 1.5 enter: 5 //44.614> 1.5 handle: 5 //44.616> 1.5 results: [ 1, 2 ] iterator代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 将一组函数包装成为一个iterator，初次调用此iterator时，会执行定义中的第一个函数并返回第二个函数以供调用。 * 也可通过手动调用 next() 得到以下一个函数为起点的新的iterator。 * 该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它。 */ // async.iterator(tasks) var iter = async.iterator([ function () {log('I am 111')}, function () {log('I am 222')}, function () {log('I am 333')} ]); /** * 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator */ //1.1 log('1.1 iter()'); var it1 = iter(); it1(); it1(); //28.368> 1.1 iter() //28.371> I am 111 //28.372> I am 222 //28.372> I am 222 /** * 通过iter()来调用下一个函数 */ log('1.2 iter()'); var it2 = iter(); var it3 = it2(); var it4 = it3(); //it4(); // 这句代码执行会报错 log(it4); // => 'null' //32.449> 1.2 iter() //32.452> I am 111 //32.452> I am 222 //32.453> I am 333 //32.454> null /** * 调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator * 对于同一个iterator，多次调用next()，不会影响自己 */ //1.3 log('1.3 iter()'); var it5 = iter.next(); it5(); var it6 = iter.next().next(); it6(); iter(); //39.895> 1.3 iter() //39.898> I am 222 //39.899> I am 333 //39.899> I am 111 map代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 对集合中的每一个元素，执行某个异步操作，得到结果。所有的结果将汇总到最终的callback里。与each的区别是，each只关心操作不管最后的值，而map关心的最后产生的值。 * * 提供了两种方式： * 1. 并行执行。同时对集合中所有元素进行操作，结果汇总到最终callback里。如果出错，则立刻返回错误以及已经执行完的任务的结果，未执行完的占个空位 * 2. 顺序执行。对集合中的元素一个一个执行操作，结果汇总到最终callback里。如果出错，则立刻返回错误以及已经执行完的结果，未执行的被忽略。 */ // map(arr, iterator(item, callback), callback(err, results)) var arr = [{name:'Jack', delay:200}, {name:'Mike', delay: 100}, {name:'Freewind', delay:300}, {name:'Test', delay: 50}]; /** * 所有操作均正确执行，未出错。所有结果按元素顺序汇总给最终的callback。 */ // 1.1 async.map(arr, function(item, callback) { log('1.1 enter: ' + item.name); setTimeout(function() { log('1.1 handle: ' + item.name); callback(null, item.name + '!!!'); }, item.delay); }, function(err,results) { log('1.1 err: ', err); log('1.1 results: ', results); }); // 54.569> 1.1 enter: Jack // 54.569> 1.1 enter: Mike // 54.569> 1.1 enter: Freewind // 54.569> 1.1 enter: Test // 54.629> 1.1 handle: Test // 54.679> 1.1 handle: Mike // 54.789> 1.1 handle: Jack // 54.879> 1.1 handle: Freewind // 54.879> 1.1 err: // 54.879> 1.1 results: [ 'Jack!!!', 'Mike!!!', 'Freewind!!!', 'Test!!!' ] /** * 如果中途出错，立刻将错误、以及已经执行完成的结果汇总给最终callback。未执行完的将会在结果数组中用占个空位。 */ async.map(arr, function(item, callback) { log('1.2 enter: ' + item.name); setTimeout(function() { log('1.2 handle: ' + item.name); if(item.name==='Jack') callback('myerr'); else callback(null, item.name+'!!!'); }, item.delay); }, function(err, results) { log('1.2 err: ', err); log('1.2 results: ', results); }); // 54.569> 1.2 enter: Jack // 54.569> 1.2 enter: Mike // 54.569> 1.2 enter: Freewind // 54.569> 1.2 enter: Test // 54.629> 1.2 handle: Test // 54.679> 1.2 handle: Mike // 54.789> 1.2 handle: Jack // 54.789> 1.2 err: myerr // 54.789> 1.2 results: [ undefined, 'Mike!!!', , 'Test!!!' ] // 54.879> 1.2 handle: Freewind /** * 顺序执行，一个完了才执行下一个。 */ async.mapSeries(arr, function(item, callback) { log('1.3 enter: ' + item.name); setTimeout(function() { log('1.3 handle: ' + item.name); callback(null, item.name+'!!!'); }, item.delay); }, function(err,results) { log('1.3 err: ', err); log('1.3 results: ', results); }); // 54.569> 1.3 enter: Jack // 54.789> 1.3 handle: Jack // 54.789> 1.3 enter: Mike // 54.899> 1.3 handle: Mike // 54.899> 1.3 enter: Freewind // 55.209> 1.3 handle: Freewind // 55.209> 1.3 enter: Test // 55.269> 1.3 handle: Test // 55.269> 1.3 err: // 55.269> 1.3 results: [ 'Jack!!!', 'Mike!!!', 'Freewind!!!', 'Test!!!' ] /** * 顺序执行过程中出错，只把错误以及执行完的传给最终callback，未执行的忽略。 */ async.mapSeries(arr, function(item, callback) { log('1.4 enter: ' + item.name); setTimeout(function() { log('1.4 handle: ' + item.name); if(item.name==='Mike') callback('myerr'); else callback(null, item.name+'!!!'); }, item.delay); }, function(err, results) { log('1.4 err: ', err); log('1.4 results: ', results); }); // 47.616> 1.4 enter: Jack // 47.821> 1.4 handle: Jack // 47.821> 1.4 enter: Mike // 47.931> 1.4 handle: Mike // 47.931> 1.4 err: myerr // 47.932> 1.4 results: [ 'Jack!!!', undefined ] /** * 并行执行，同时最多2个函数并行，传给最终callback。 */ //1.5 async.mapLimit(arr,2, function(item, callback) { log('1.5 enter: ' + item.name); setTimeout(function() { log('1.5 handle: ' + item.name); if(item.name==='Jack') callback('myerr'); else callback(null, item.name+'!!!'); }, item.delay); }, function(err, results) { log('1.5 err: ', err); log('1.5 results: ', results); }); //57.797> 1.5 enter: Jack //57.800> 1.5 enter: Mike //57.900> 1.5 handle: Mike //57.900> 1.5 enter: Freewind //58.008> 1.5 handle: Jack //58.009> 1.5 err: myerr //58.009> 1.5 results: [ undefined, 'Mike!!!' ] //58.208> 1.5 handle: Freewind //58.208> 1.5 enter: Test //58.273> 1.5 handle: Test nextTick代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * nextTick的作用与nodejs的nextTick一样，再最后调用函数。 * 但在浏览器端，只能使用setTimeout(callback,0)，但这个方法有时候会让其它高优先级的任务插到前面去。 * 所以提供了这个nextTick，让同样的代码在服务器端和浏览器端表现一致。 */ // nextTick(callback) var calls = []; async.nextTick(function() { calls.push('two'); }); async.nextTick(function() { log('1.1',calls); }); calls.push('one'); log('1.2',calls); async.nextTick(function() { log('1.3',calls); }); //09.838> 1.2[ 'one' ] //09.842> 1.1[ 'one', 'two' ] //09.843> 1.3[ 'one', 'two' ] parallel代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。 * * 如果某个函数出错，则立刻将err和已经执行完的函数的结果值传给parallel最终的callback。其它未执行完的函数的值不会传到最终数据，但要占个位置。 * 同时支持json形式的tasks，其最终callback的结果也为json形式。 */ // parallel(tasks, [callback]) /** * 并行执行多个函数，每个函数的值将按函数声明的先后顺序汇成一个数组，传给最终callback。 */ // 1.1 async.parallel([ function(cb) { t.fire('a400', cb, 400) }, function(cb) { t.fire('a200', cb, 200) }, function(cb) { t.fire('a300', cb, 300) } ], function (err, results) { log('1.1 err: ', err); log('1.1 results: ', results); }); //36.929> 1.1 err: null //36.930> 1.1 results: [ 'a400', 'a200', 'a300' ] /** * 如果中途有个函数出错，则将该err和已经完成的函数值汇成一个数组，传给最终的callback。还没有执行完的函数的值将被忽略，但要在最终数组中占个位置 */ // 1.2 async.parallel([ function(cb) { log('1.2.1: ', 'start'); t.fire('a400', cb, 400) }, // 该函数的值不会传给最终callback，但要占个位置 function(cb) { log('1.2.2: ', 'start'); t.err('e200', cb, 200) }, function(cb) { log('1.2.3: ', 'start'); t.fire('a100', cb, 100) } ], function(err, results) { log('1.2 err: ', err); log('1.2 results: ', results); }); //36.537> 1.2.1: start //36.540> 1.2.2: start //36.541> 1.2.3: start //36.741> 1.2 err: e200 //36.744> 1.2 results: [ , undefined, 'a100' ] /** * 以json形式传入tasks，最终results也为json */ // 1.3 async.parallel({ a: function(cb) { t.fire('a400', cb, 400) }, b: function(cb) { t.fire('c300', cb, 300) } }, function(err, results) { log('1.3 err: ', err); log('1.3 results: ', results); }); //36.943> 1.3 err: null //36.944> 1.3 results: { b: 'c300', a: 'a400' } /** * 如果中途出错，会将err与已经完成的函数值（汇成一个json）传给最终callback。未执行完成的函数值被忽略，不会出现在最终json中。 */ // 1.4 async.parallel({ a: function(cb) { t.fire('a400', cb, 400) }, // 该函数的值不会传给最终的callback b: function(cb) { t.err('e300', cb, 300) }, c: function(cb) { t.fire('c200', cb, 200) } }, function(err, results) { log('1.4 err: ', err); log('1.4 results: ', results); }); //36.853> 1.4 err: e300 //36.854> 1.4 results: { c: 'c200', b: undefined } /** * 并行执行，同时最多2个函数并行，传给最终callback。 */ //1.5 async.parallelLimit({ a:function(cb) { log('a start'); t.fire('a400', cb, 200) }, b:function(cb) { log('b start'); t.fire('b200', cb, 200) }, c:function(cb) { log('c start'); t.fire('c100', cb, 100) }, d:function(cb) { log('d start'); t.fire('d600', cb, 600) }, e:function(cb) { log('e start'); t.fire('e300', cb, 300) } },2, function(err, results) { log('1.5 err: ', err); log('1.5 results: ', results); }); //26.993> a start //26.996> b start //27.200> c start //27.202> d start //27.313> e start //27.809> 1.5 err: //27.810> 1.5 results: { a: 'a400', b: 'b200', c: 'c100', e: 'e300', d: 'd600' } queue代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * queue是一个串行的消息队列，通过限制了worker数量，不再一次性全部执行。 * 当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。 * * 该函数有多个点可供回调，如worker用完时、无等候任务时、全部执行完时等。 */ // queue(worker, concurrency) /** * 定义一个queue，设worker数量为2 */ var q = async.queue(function(task, callback) { log('worker is processing task: ', task.name); task.run(callback); }, 2); /** * 监听：如果某次push操作后，任务数将达到或超过worker数量时，将调用该函数 */ q.saturated = function() { log('all workers to be used'); } /** * 监听：当最后一个任务交给worker时，将调用该函数 */ q.empty = function() { log('no more tasks wating'); } /** * 监听：当所有任务都执行完以后，将调用该函数 */ q.drain = function() { log('all tasks have been processed'); } /** * 独立加入2个任务 */ q.push({name:'t1', run: function(cb){ log('t1 is running, waiting tasks: ', q.length()); t.fire('t1', cb, 400); // 400ms后执行 }}, function(err) { log('t1 executed'); }); log('pushed t1, waiting tasks: ', q.length()); q.push({name:'t2',run: function(cb){ log('t2 is running, waiting tasks: ', q.length()); t.fire('t2', cb, 200); // 200ms后执行 }}, function(err) { log('t2 executed'); }); log('pushed t2, waiting tasks: ', q.length()); //54.448> pushed t1, waiting tasks: 1 //54.451> all workers to be used //54.452> pushed t2, waiting tasks: 2 //54.452> worker is processing task: t1 //54.453> t1 is running, waiting tasks: 1 //54.455> no more tasks wating //54.455> worker is processing task: t2 //54.455> t2 is running, waiting tasks: 0 //54.656> t2 executed //54.867> t1 executed //54.868> all tasks have been processed // 同时加入多个任务 q.push([ { name:'t3', run: function(cb){ log('t3 is running, waiting tasks: ', q.length()); t.fire('t3', cb, 300); // 300ms后执行 } },{ name:'t4', run: function(cb){ log('t4 is running, waiting tasks: ', q.length()); t.fire('t4', cb, 500); // 500ms后执行 } },{ name:'t5', run: function(cb){ log('t5 is running, waiting tasks: ', q.length()); t.fire('t5', cb, 100); // 100ms后执行 } },{ name:'t6', run: function(cb){ log('t6 is running, waiting tasks: ', q.length()); t.fire('t6', cb, 400); // 400ms后执行 } } ], function(err) { log('err: ',err); }); log('pushed t3,t4,t5,t6 into queue, waiting tasks: ', q.length()); //53.755> all workers to be used //53.758> pushed t3,t4,t5,t6 into queue, waiting tasks: 4 //53.759> worker is processing task: t3 //53.760> t3 is running, waiting tasks: 3 //53.762> worker is processing task: t4 //53.762> t4 is running, waiting tasks: 2 //54.073> err: null //54.074> worker is processing task: t5 //54.076> t5 is running, waiting tasks: 1 //54.183> err: null //54.184> no more tasks wating //54.185> worker is processing task: t6 //54.186> t6 is running, waiting tasks: 0 //54.265> err: null //54.588> err: null //54.589> all tasks have been processed Reduce代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * Reduce可以让我们给定一个初始值，用它与集合中的每一个元素做运算，最后得到一个值。reduce从左向右来遍历元素，如果想从右向左，可使用reduceRight。 */ //reduce(arr, memo, iterator(memo,item,callback), callback(err,result)) //alias: inject, foldl var arr = [1,3,5]; /** * 顺序执行 */ async.reduce(arr, 100, function(memo, item, callback) { log('1.1 enter: ' + memo +', ' + item); setTimeout(function() { callback(null, memo+item); }, 100); },function(err, result) { log('1.1 err: ', err); log('1.1 result: ', result); }); // 28.789> 1.1 enter: 100, 1 // 28.889> 1.1 enter: 101, 3 // 28.999> 1.1 enter: 104, 5 // 29.109> 1.1 err: // 29.109> 1.1 result: 109 /** * 顺序执行过程中出错，只把错误传给最终callback，结果是null */ async.reduce(arr, 100, function(memo, item, callback) { log('1.2 enter: ' + memo +', ' + item); setTimeout(function() { if(item===3) callback('myerr'); else callback(null, memo+item); }, 100); },function(err, result) { log('1.2 err: ', err); log('1.2 result: ', result); }); // 05.541> 1.2 enter: 100, 1 // 05.649> 1.2 enter: 101, 3 // 05.760> 1.2 err: myerr // 05.760> 1.2 result: /** * 顺序执行从右向左 * * alias: foldr */ async.reduceRight(arr, 100, function(memo, item, callback) { log('1.3 enter: ' + memo +', ' + item); setTimeout(function() { callback(null, memo+item); }, 100); },function(err, result) { log('1.3 err: ', err); log('1.3 result: ', result); }); // 28.789> 1.3 enter: 100, 5 // 28.889> 1.3 enter: 105, 3 // 28.999> 1.3 enter: 108, 1 // 29.109> 1.3 err: // 29.109> 1.3 result: 109 /** * 通过t.inc做一个累加器，参与reduce的计算 */ async.reduce(arr, 100, function(memo,item,callback) { log('1.4 enter: '+memo+','+item); t.inc(item, function(err,n) { log('1.4 handle: ',n); callback(null, memo+n); }); }, function(err,result) { log('1.4 err: ', err); log('1.4 result: ', result); }); // 28.789> 1.4 enter: 100,1 // 28.999> 1.4 handle: 2 // 28.999> 1.4 enter: 102,3 // 29.209> 1.4 handle: 4 // 29.209> 1.4 enter: 106,5 // 29.409> 1.4 handle: 6 // 29.409> 1.4 err: // 29.409> 1.4 result: 112 // --> spent 0.62s /** * 通过t.inc做一个累加器，并实现对map的结果集做reduce */ async.map(arr, function(item, callback) { log('1.5 enter: ', item); t.inc(item, function(err,n){ log('1.5 handle: ', n); callback(null,n); }); },function(err, results) { log('1.5 err: ', err); log('1.5 results: ', results); var sum = results.reduce(function(memo, item) { return memo + item; }, 100); log('1.5 sum: ', sum); }); // 28.789> 1.5 enter: 1 // 28.789> 1.5 enter: 3 // 28.789> 1.5 enter: 5 // 28.999> 1.5 handle: 2 // 28.999> 1.5 handle: 4 // 28.999> 1.5 handle: 6 // 28.999> 1.5 err: // 28.999> 1.5 results: [ 2, 4, 6 ] // 28.999> 1.5 sum: 112 // --> spent 0.21 series代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。 * * 如果任何一个函数向它的回调函数中传了一个error，则后面的函数都不会被执行，并且会立刻将该error以及已经执行了的函数的结果，传给series中最后那个callback。 * 当所有的函数执行完后（没有出错），则会把每个函数传给其回调函数的结果合并为一个数组，传给series最后的那个callback。 * 还可以json的形式来提供tasks。每一个属性都会被当作函数来执行，并且结果也会以json形式传给series最后的那个callback。这种方式可读性更高一些。 */ // series(tasks, [callback]) /** * 全部函数都正常执行。每个函数产生的值将按顺序合并为一个数组，传给最终的callback。 */ // 1.1 async.series([ function(cb) { t.inc(3, cb); }, function(cb) { t.inc(8, cb); }, function(cb) { t.inc(2, cb); } ], function(err, results) { log('1.1 err: ', err); log('1.1 results: ', results); }); //05.155> 1.1 err: null //05.156> 1.1 results: [ 4, 9, 3 ] /** * 中间有函数出错。出错之后的函数不会执行，错误及之前正常执行的函数结果将传给最终的callback。 */ // 1.2 async.series([ function(cb) { t.inc(3, cb); }, function(cb) { t.err('test_err', cb); }, function(cb) { t.inc(8, cb); } ], function (err, results) { log('1.2 err: ', err); log('1.2 results: ', results); }); //04.964> 1.2 err: test_err //04.973> 1.2 results: [ 4, undefined ] /** * 如果某个函数传的数据是undefined, null, {}, []等，它们会原样传给最终callback。 */ // 1.3 async.series([ function(cb) { t.fire(3, cb);}, function(cb) { t.fire(undefined, cb); }, function(cb) { t.fire(null, cb); }, function(cb) { t.fire({}, cb); }, function(cb) { t.fire([], cb); }, function(cb) { t.fire('abc', cb) } ], function(err, results) { log('1.3 err: ', err); log('1.3 results: ', results); }); //05.794> 1.3 err: null //05.795> 1.3 results: [ 3, undefined, null, {}, [], 'abc' ] /** * 以json形式传入tasks。其结果也将以json形式传给最终callback。 */ async.series({ a: function(cb) { t.inc(3, cb); }, b: function(cb) { t.fire(undefined, cb); }, c: function (cb) { t.err('myerr', cb); }, d: function (cb) { t.inc(8, cb); } }, function (err, results) { log('1.4 err: ', err); log('1.4 results: ', results); }); //05.178> 1.4 err: myerr //05.179> 1.4 results: { a: 4, b: undefined, c: undefined } some代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 当集合中是否有至少一个元素满足条件时，最终callback得到的值为true，否则为false. */ // some(arr, iterator(item,callback(test)), callback(result)) //alias: any var arr = [1,2,3,6]; /** * 串行执行，集合中至少有一个元素&lt;=3，所以结果为true */ // 1.1 async.some(arr, function(item,callback){ log('1.1 enter: ',item); setTimeout(function(){ log('1.1 handle: ',item); callback(item&lt;=3); },100); }, function(result) { log('1.1 result: ', result); }); // 36.165> 1.1 enter: 1 // 36.165> 1.1 enter: 2 // 36.165> 1.1 enter: 3 // 36.165> 1.1 enter: 6 // 36.275> 1.1 handle: 1 // 36.275> 1.1 result: true // 36.275> 1.1 handle: 2 // 36.275> 1.1 handle: 3 // 36.275> 1.1 handle: 6 /** * 串行执行，集合中没有一个元素>10，所以结果为false */ async.some(arr, function(item,callback){ log('1.2 enter: ',item); setTimeout(function(){ log('1.2 handle: ',item); callback(item>10); },100); }, function(result) { log('1.2 result: ', result); }); // 36.165> 1.2 enter: 1 // 36.165> 1.2 enter: 2 // 36.165> 1.2 enter: 3 // 36.165> 1.2 enter: 6 // 36.275> 1.2 handle: 1 // 36.275> 1.2 handle: 2 // 36.275> 1.2 handle: 3 // 36.275> 1.2 handle: 6 // 36.275> 1.2 result: false sortBy代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 对集合内的元素进行排序，依据每个元素进行某异步操作后产生的值，从小到大排序。 */ // sortBy(array, iterator(item,callback(err,result)), callback(err,results)) var arr = [3,6,1]; /** * 通过异步迭代器，对集合进行排序 */ async.sortBy(arr, function(item, callback) { setTimeout(function() { callback(null,item); }, 200); }, function(err,results) { log('1.1 err: ', err); log('1.1 results: ', results); }); // 26.562> 1.1 err: null // 26.562> 1.1 results: [ 1, 3, 6 ] /** * 迭代出错，callback返回err，没有results */ async.sortBy(arr, function(item, callback) { setTimeout(function() { if(item===6) callback('myerr'); else callback(null,item); }, 200); }, function(err,results) { log('1.2 err: ', err); log('1.2 results: ', results); }); // 26.572> 1.2 err: myerr // 26.572> 1.2 results: t.js代码演示// 其实这个文件名的't'我不是很明白原作者freewind的意思，我觉得叫做'lib.js'或者 // 'helper.js'比较合适，因为这里面都是些辅助函数。 var moment = require('moment'); exports.inc = function(n, callback, timeout) { //将参数n自增1之后的结果返回给async timeout = timeout || 200; setTimeout(function() { callback(null, n+1); }, timeout); }; exports.fire = function(obj, callback, timeout) { //直接将obj的内容返回给async timeout = timeout || 200; setTimeout(function() { callback(null, obj); }, timeout); }; exports.err = function(errMsg, callback, timeout) { //模拟一个错误的产生，让async各个函数末尾的callback接收到。 timeout = timeout || 200; setTimeout(function() { callback(errMsg); }, timeout); }; // utils exports.log = function(msg, obj) { //对console.log进行了封装。主要是增加了秒钟的输出，通过秒数的差值方便大家对async的理解。 process.stdout.write(moment().format('ss.SSS')+'> '); if(obj!==undefined) { process.stdout.write(msg); console.log(obj); } else { console.log(msg); } }; exports.wait = function(mils) { //刻意等待mils的时间，mils的单位是毫秒。 var now = new Date; while(new Date - now &lt;= mils); } times timesSeries代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 异步运行,times可以指定调用几次，并把结果合并到数组中返回 */ // times(n, callback) function delay(n){return (n+12) % 7 *100;} var createUser = function(id, callback) { callback(null, { id: 'user' + id, delay:delay(id) }) } /** * 异步执行，调用3次createUser函数，结果被合并到数组返回 */ //1.1 async.times(3, function(n, callback){ log(\"1.1 enter: \"+ n); setTimeout(function(){ log('1.1 handler: ',n); createUser(n, function(err, user) { callback(err, user) }) },delay(n)); }, function(err, users) { log('1.1 err: ',err); log('1.1 result: ',users); }); //07.397> 1.1 enter: 0 //07.400> 1.1 enter: 1 //07.401> 1.1 enter: 2 //07.412> 1.1 handler: 2 //07.912> 1.1 handler: 0 //08.009> 1.1 handler: 1 //08.010> 1.1 err: null //08.011> 1.1 result: [ { id: 'user0', delay: 500 }, // { id: 'user1', delay: 600 }, // { id: 'user2', delay: 0 } ] /** * timesSeries与time唯一不同的是，同步执行 */ //timesSeries(n, callback) /** * 同步执行，调用3次createUser函数，结果被合并到数组返回 */ //1.2 async.timesSeries(3, function(n, callback){ log(\"1.2 enter: \"+ n); setTimeout(function(){ log('1.2 handler: ',n); createUser(n, function(err, user) { callback(err, user) }) },delay(n)); }, function(err, users) { log('1.2 err: ',err); log('1.2 result: ',users); }); //16.642> 1.2 enter: 0 //17.159> 1.2 handler: 0 //17.162> 1.2 enter: 1 //17.763> 1.2 handler: 1 //17.767> 1.2 enter: 2 //17.778> 1.2 handler: 2 //17.779> 1.2 err: null //17.780> 1.2 result: [ { id: 'user0', delay: 500 }, // { id: 'user1', delay: 600 }, // { id: 'user2', delay: 0 } ] unmemoize noConflict memoize log dir 代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 让某一个函数在内存中缓存它的计算结果。对于相同的参数，只计算一次，下次就直接拿到之前算好的结果。 * hasher可以让我们自定义如何根据参数来判断它是否已经在缓存中了。 */ // memoize(fn, [hasher]) //1.1 var slow_fn = function(x, y, callback) { log('1.1 start working for: ' + x+','+y); t.wait(500); log('1.1 finished: ' + x+','+y); callback(null, x+','+y); }; var fn = async.memoize(slow_fn,function(x,y) { return x+y; }); fn('a','b', function(err, result) { log(\"1.1 first time: \"+result); }); fn('cc','d', function(err, result) { log(\"1.1 first time: \"+result); }); fn('a','b', function(err, result) { log(\"1.1 second time: \"+result); }); //15.416> 1.1 start working for: a,b //15.920> 1.1 finished: a,b //15.920> 1.1 first time: a,b //15.921> 1.1 start working for: cc,d //16.423> 1.1 finished: cc,d //16.423> 1.1 first time: cc,d //16.424> 1.1 second time: a,b /** * 让已经被缓存的函数，返回不缓存的函数引用。 */ // unmemoize(fn) //1.2 var slow_fn2 = function(x, y, callback) { log('1.2 start working for: ' + x+','+y); t.wait(500); log('1.2 finished: ' + x+','+y); callback(null, x+','+y); }; var fn2 = async.memoize(slow_fn2,function(x,y) { return x+y; }); fn2('a','b', function(err,result) { log(\"1.2 first time: \"+result); }); var unFn2 =async.unmemoize(fn2); log('1.2 unmemoized'); unFn2('a','b', function(err,result) { log(\"1.2 second time: \"+result); }); //16.424> 1.2 start working for: a,b //16.926> 1.2 finished: a,b //16.926> 1.2 first time: a,b //16.927> 1.2 unmemoized //16.927> 1.2 start working for: a,b //17.428> 1.2 finished: a,b //17.428> 1.2 second time: a,b /** * 执行某异步函数，并记录它的返回值。试验函数时很方便，不用写那些固定模式的代码。 * 如果该函数向回调中传入了多个参数，则每行记录一个。 */ // log(function, arguments) //1.3 var x = function() { this.name = 'bsspirit'; } var hello = function(name, callback) { setTimeout(function() { callback(null, 'first ' + name, 'second '+ name, x, {a:'123'} ); }, 200); }; log(\"1.3 handler\"); async.log(hello, 'time'); //37.620> 1.3 handler //first time //second time //[Function] //{ a: '123' } /** * dir与log都是打印出输，在nodejs环境中没有分别。 * dir的不同之处在于，会调用浏览器的console.dir()函数，显示为DOM视图。 * * http://stackoverflow.com/questions/10636866/whats-the-difference-between-async-log-and-async-dir */ //1.4 log(\"1.4 handler\"); async.dir(hello, 'world'); //37.620> 1.4 handler //first time //second time //[Function] //{ a: '123' } /** * noConflict()仅仅用于浏览器端，在nodejs中没用，这里无法演示。 * * 它的作用是：如果之前已经在全局域中定义了async变量，当导入本async.js时，会先把之前的async变量保存起来，然后覆盖它。 * 用完之后，调用noConflict()方法，就会归还该值。同时返回async本身供换名使用。 */ // noConflict() /* // global on the server, window in the browser var root = this, previous_async = root.async; if (typeof module !== 'undefined' &amp;&amp; module.exports) { module.exports = async; } else { root.async = async; } async.noConflict = function () { root.async = previous_async; return async; }; */ waterfall代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 按顺序依次执行一组函数。每个函数产生的值，都将传给下一个。 * 如果中途出错，后面的函数将不会被执行。错误信息将传给waterfall最终的callback。之前产生的结果被丢弃。 * * 这个函数名为waterfall(瀑布)，可以想像瀑布从上到下，中途冲过一层层突起的石头。 * * 注意，该函数不支持json格式的tasks */ // async.waterfall(tasks, [callback]); /** * 所有函数正常执行，每个函数的结果都将变为下一个函数的参数。 * * 注意，所有的callback都必须形如callback(err, result)，但err参数在前面各函数中无需声明，它被自动处理。 */ // 1.1 async.waterfall([ function(cb) { log('1.1.1: ', 'start'); cb(null, 3); }, function(n, cb) { log('1.1.2: ',n); t.inc(n, cb); }, function(n, cb) { log('1.1.3: ',n); t.fire(n*n, cb); } ], function (err, result) { log('1.1 err: ', err); log('1.1 result: ', result); }); //31.749> 1.1.1: start //31.752> 1.1.2: 3 //31.953> 1.1.3: 4 //32.156> 1.1 err: null //32.159> 1.1 result: 16 /** * 中途有函数出错，其err直接传给最终callback，结果被丢弃，后面的函数不再执行。 */ // 1.2 async.waterfall([ function(cb) { log('1.2.1: ', 'start'); cb(null, 3); }, function(n, cb) { log('1.2.2: ', n); t.inc(n, cb); }, function(n, cb) { log('1.2.3: ', n); t.err('myerr', cb); }, function(n, cb) { log('1.2.4: ', n); t.fire(n, cb); } ], function (err, result) { log('1.2 err: ', err); log('1.2 result: ', result); }); //44.935> 1.2.1: start //44.939> 1.2.2: 3 //45.140> 1.2.3: 4 //45.344> 1.2 err: myerr //45.348> 1.2 result: /** * 注意： 以json形式传入tasks，将不会被执行!! */ async.waterfall({ a: function(cb) { log('1.3.1: ', 'start'); cb(null, 3); }, b: function(n, cb) { log('1.3.2: ', n); t.inc(n, cb); }, c: function(n, cb) { log('1.3.3: ', n); t.fire(n*n, cb); } }, function (err, result) { log('1.3 err: ', err); log('1.3 result: ', result); }); //49.222> 1.3 err: [Error: First argument to waterfall must be an array of functions] //49.228> 1.3 result: whilst until doUntil forever和 doWhilst代码演示var async = require('async'); var t = require('./t'); var log = t.log; /** * 相当于while，但其中的异步调用将在完成后才会进行下一次循环。 * * 它相当于： * try { * whilst(test) { * fn(); * } * callback(); * } catch (err) { * callback(err); * } * * 该函数的功能比较简单，条件变量通常定义在外面，可供每个函数访问。在循环中，异步调用时产生的值实际上被丢弃了，因为最后那个callback只能传入错误信息。 * * 另外，第二个函数fn需要能接受一个函数cb，这个cb最终必须被执行，用于表示出错或正常结束。 */ // whilst(test, fn, callback) /** * 正常情况，没有出错。第二个函数虽然是异步调用，但被同步执行。所以第三个函数被调用时，已经过了3秒。 */ // 1.1 var count1 = 0; async.whilst( function() { return count1 &lt; 3 }, function(cb) { log('1.1 count: ', count1); count1++; setTimeout(cb, 1000); }, function(err) { // 3s have passed log('1.1 err: ', err); } ); //10.318> 1.1 count: 0 //11.330> 1.1 count: 1 //12.342> 1.1 count: 2 //13.356> 1.1 err: /** * 中途出错。出错后立刻调用第三个函数。 */ // 1.2 var count2 = 0; async.whilst( function() { return count2 &lt; 3 }, function(cb) { log('1.2 count: ', count2); if(count2===1) { t.err('myerr', cb, 200); } else { count2++; setTimeout(cb, 1000); } }, function(err) { // 2s have passed log('1.2 err: ', err); } ); //12.805> 1.2 count: 0 //13.824> 1.2 count: 1 //14.026> 1.2 err: myerr /** * 第二个函数即使产生值，也会被忽略。第三个函数只能得到err。 */ // 1.3 var count3 = 0; async.whilst( function() {return count3 &lt; 3 }, function(cb) { log('1.3 count: ', count3); t.inc(count3++, cb); }, function(err,result){ // result没有用 log('1.3 err: ', err); log('1.3 result: ', result); } ); //45.311> 1.3 count: 0 //45.514> 1.3 count: 1 //45.718> 1.3 count: 2 //45.920> 1.3 err: //45.923> 1.3 result: /** * doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。 和javascript中do..while语法一致。 */ // doWhilst(fn, test, callback) //1.4 var count4 = 0; async.doWhilst( function(cb) { log('1.4 count: ', count4); t.inc(count4++, cb); }, function() { log(\"1.4 test\"); return count4 &lt; 3 }, function(err,result){ // result没有用 log('1.4 err: ', err); log('1.4 result: ', result); } ); //33.643> 1.4 count: 0 //33.848> 1.4 test //33.850> 1.4 count: 1 //34.054> 1.4 test //34.057> 1.4 count: 2 //34.269> 1.4 test //34.270> 1.4 err: //34.270> 1.4 result: /** * until与whilst正好相反，当test为false时循环，与true时跳出。其它特性一致。 */ // 1.5 var count5 = 0; async.until( function() { return count5>3 }, function(cb) { log('1.5 count: ', count5); count5++; setTimeout(cb, 200); }, function(err) { // 4s have passed log('1.5 err: ',err); } ); //42.498> 1.5 count: 0 //42.701> 1.5 count: 1 //42.905> 1.5 count: 2 //43.107> 1.5 count: 3 //43.313> 1.5 err: /** * doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。 */ // doUntil(fn, test, callback) // 1.6 var count6 = 0; async.doUntil( function(cb) { log('1.6 count: ', count6); count6++; setTimeout(cb, 200); }, function() { log('1.6 test');return count6>3 }, function(err) { // 4s have passed log('1.6 err: ',err); } ); //41.831> 1.6 count: 0 //42.035> 1.6 test //42.037> 1.6 count: 1 //42.241> 1.6 test //42.244> 1.6 count: 2 //42.456> 1.6 test //42.457> 1.6 count: 3 //42.660> 1.6 test //42.661> 1.6 err: /** * forever，无论条件循环执行，如果不出错，callback永远不被执行 */ //forever(fn, callback) //1.7 var count7 = 0; async.forever( function(cb) { log('1.7 count: ', count7); count7++; setTimeout(cb, 200); }, function(err) { log('1.7 err: ',err); } ); //52.770> 1.7 count: 0 //52.973> 1.7 count: 1 //53.175> 1.7 count: 2 //53.377> 1.7 count: 3 //53.583> 1.7 count: 4 //53.785> 1.7 count: 5 //53.987> 1.7 count: 6 //54.189> 1.7 count: 7 //54.391> 1.7 count: 8 //54.593> 1.7 count: 9 //54.795> 1.7 count: 10 //54.997> 1.7 count: 11 //55.199> 1.7 count: 12","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.msiter.com/tags/nodejs/"},{"name":"async","slug":"async","permalink":"http://www.msiter.com/tags/async/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.msiter.com/categories/服务器/"}]}]}